<hr>
<p>title: PAT<br>date: 2020-01-06 07:26:48<br>tags: </p>
<ul>
<li>2020<br>top_img: <a href="https://cdn.jsdelivr.net/gh/RangerWang/butterfly_cdn@v0.5/top_img/wallpaper11.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/RangerWang/butterfly_cdn@v0.5/top_img/wallpaper11.jpg</a><br>cover: <a href="https://cdn.jsdelivr.net/gh/RangerWang/butterfly_cdn@v0.5/top_img/wallpaper11.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/RangerWang/butterfly_cdn@v0.5/top_img/wallpaper11.jpg</a><br>toc: true<br>toc_number: true<br>mathjax: true<br>categories:</li>
<li>history</li>
<li>2020</li>
<li>408<br>comments: true<br>password: 1<br>message: ‘抱歉, 此乃南墙, 请回头…’</li>
</ul>
<hr>
<h1 id="Morning-Reading"><a href="#Morning-Reading" class="headerlink" title="Morning Reading"></a>Morning Reading</h1><ul>
<li>数据结构（45）</li>
<li>计算机组成原理（45）</li>
<li>计算机网络（25）</li>
<li>计算机操作系统（35）</li>
</ul>
<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><h3 id="考查目标"><a href="#考查目标" class="headerlink" title="[考查目标]"></a>[考查目标]</h3><p>1。掌握数据结构的基本概念、基本原理和基本方法。<br>2。掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复<br>杂度与空间复杂度的分析。<br>3。能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用 C 或 C++语言<br>设计与实现算法的能力。</p>
<h3 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h3><p>（一）线性表的定义和基本操作<br>（二）线性表的实现<br>1。顺序存储<br>2。链式存储<br>3。线性表的应用</p>
<h3 id="二、栈、队列和数组"><a href="#二、栈、队列和数组" class="headerlink" title="二、栈、队列和数组"></a>二、栈、队列和数组</h3><p>（一）栈和队列的基本概念<br>（二）栈和队列的顺序存储结构<br>（三）栈和队列的链式存储结构<br>（四）栈和队列的应用<br>（五）特殊矩阵的压缩存储</p>
<h3 id="三、树与二叉树"><a href="#三、树与二叉树" class="headerlink" title="三、树与二叉树"></a>三、树与二叉树</h3><p>（一）树的基本概念<br>（二）二叉树<br>1。二叉树的定义及其主要特征<br>2。二叉树的顺序存储结构和链式存储结构<br>3。二叉树的遍历<br>4。线索二叉树的基本概念和构造<br>（三）树、森林<br>1。树的存储结构<br>2。森林与二叉树的转换<br>3。树和森林的遍历<br>（四）树与二叉树的应用<br>1。二叉排序树<br>2。平衡二叉树<br>3。哈夫曼（Huffman）树和哈夫曼编码</p>
<h3 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h3><p>（一）图的基本概念<br>（二）图的存储及基本操作<br>1。邻接矩阵法<br>2。邻接表法<br>3。邻接多重表、十字链表<br>（三）图的遍历<br>1。深度优先搜索<br>2。广度优先搜索<br>（四）图的基本应用<br>1。最小（代价）生成树<br>2。最短路径<br>3。拓扑排序<br>4。关键路径</p>
<h3 id="五、查找"><a href="#五、查找" class="headerlink" title="五、查找"></a>五、查找</h3><p>（一）查找的基本概念<br>（二）顺序查找法<br>（三）分块查找法<br>（四）折半查找法<br>（五）B 树及其基本操作、B+树的基本概念<br>（六）散列（Hash）表<br>（七）字符串模式匹配<br>（八）查找算法的分析及应用</p>
<h3 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h3><p>（一）排序的基本概念<br>（二）插入排序<br>1。直接插入排序<br>2。折半插入排序<br>（三）气泡排序（bubble sort）<br>（四）简单选择排序<br>（五）希尔排序（shell sort）<br>（六）快速排序<br>（七）堆排序<br>（八）二路归并排序（merge sort）<br>（九）基数排序<br>（十）外部排序<br>（十一）各种内部排序算法的比较<br>（十二）排序算法的应用</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><pre><code class="lang-mermaid">graph LR
    A(绪论) --- B(数据结构)

    B --- B1(逻辑结构)
    B --- B2(&quot;存储结构(物理结构)&quot;)
    B --- B3(数据的运算)
    B1 --- B11(&quot;线性结构: 线性表, 栈, 队列&quot;)
    B1 --- B12(&quot;非线性结构: 树, 图, 集合&quot;)

    A --- C(五个特征)
    C --- C1(算法定义)
    C --- C2(&quot;五个特性: 有穷, 确定, 可行, 输出, 输出&quot;)
    C --- C3(效率的度量)
    C3 --- C11(时间复杂度)
    C3 --- C12(空间复杂度)
</code></pre>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><blockquote>
<p>数据, 数据元素, 数据对象, 数据类型, 抽象数据类型, 数据结构</p>
<blockquote>
<p>抽象数据类型(ADT): 指一个数据模型及定义在该模型上的一组操作; 其定义仅取决于它的一组逻辑特性; 常用(数据对象, 数据关系, 基本操作集)表示</p>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。包含三方面内容(逻辑结构, 存储结构和数据运算)</p>
</blockquote>
</blockquote>
<ul>
<li><p>数据的逻辑结构</p>
<pre><code class="lang-mermaid">  graph LR    
      A(数据的逻辑结构) --- B(线性结构)
      B --- B1(一般线性表)
      B --- B2(受限线性表)
      B2 --- B21(栈和队列)
      B2 --- B22(串)
      B --- B3(线性表推广)
      B3 --- B31(数组)
      B3 --- B32(广义表)
      A --- C(非线性结构)
      C --- C1(集合)
      C --- C2(树形结构)
      C2 --- C21(一般树)
      C2 --- C22(二叉树)
      C --- C3(图状结构)
      C3 --- C31(有向图)
      C3 --- C32(无向图)
</code></pre>
</li>
<li><p>存储结构</p>
<ul>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储(Hash存储)</li>
</ul>
</li>
</ul>
<h3 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h3><ul>
<li><p>时间复杂度</p>
<blockquote>
<p>算法中所有语句的频度之和记为 T(n), 时间复杂度主要分析 T(n)的数量级。<br>常用算法中基本运算的频度 f(n)来分析算法的时间复杂度. 记为 T(n) = O(f(n))<br>常见的渐近时间复杂度为:</p>
<blockquote>
<p>O(1) &lt; O($log<em>{2}n$) &lt; O(n) &lt; O($nlog</em>{2}n$) &lt; O($n^2$) &lt; O($n^3$) &lt; O($2^n$) &lt; O($n!$) &lt; O($n^n$)</p>
</blockquote>
</blockquote>
</li>
<li><p>空间复杂度</p>
</li>
</ul>
<h2 id="Linear-List"><a href="#Linear-List" class="headerlink" title="Linear List"></a>Linear List</h2><pre><code class="lang-mermaid">graph LR
    A(线性表) --- B(顺序存储)
    B --- B1(顺序表)
    A(线性表) --- C(链式存储)
    C --- C1(单链表)
    C1 --- C5(指针实现)
    C --- C2(双链表)
    C2 --- C5
    C --- C3(循环链表)
    C3 --- C5(指针实现)
    C --- C4(&quot;静态链表(借助数组实现)&quot;)
</code></pre>
<h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><ul>
<li><p>定义</p>
<pre><code class="lang-c">#define InitSize 100
typedef struct {
    ElemType *data;
    int MaxSize, length;
}
</code></pre>
</li>
</ul>
<ul>
<li>线性表中的位序从1开始，数组中的元素的下标是从0开始的</li>
<li>主要特点: 随机访问，即通过首地址和元素序号可在时间O(1)内找到指定元素。</li>
<li>存储密度高，每个节点只存储输出元素</li>
<li>O(n)  插入，删除，顺序查找</li>
</ul>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>链表，无论单链表，双链表还是循环链表，一定要保证不断链。</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li><p>定义</p>
<pre><code class="lang-c">  typedef struct LNode{
  ElemType data;
      struct LNode *next;
        }LNode, *LinkList
</code></pre>
<p>```</p>
</li>
<li><p>不管带不带头结点，头指针始终指向链表的第一个结点</p>
</li>
<li><p>头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。(加入头结点，空表和非空表的处理得到统一)</p>
</li>
<li><p>O(n)</p>
<ul>
<li>头插法建立单链表</li>
<li>尾插发建立单链表</li>
<li>按序号查找结点值</li>
<li>按值查找表结点</li>
<li>插入结点操作</li>
<li>删除结点操作</li>
<li>求表长操作</li>
</ul>
</li>
</ul>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><ul>
<li>定义<pre><code class="lang-c">typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;
} DNode, *DLinklist;
</code></pre>
</li>
</ul>
<h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><ul>
<li>循环单链表</li>
<li>循环双链表</li>
</ul>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>借助数组来描述线性表的链式存储结构，这里的指针是结点的相对地址(数组下标)，又称游标。</p>
<h3 id="如何选取存储结构"><a href="#如何选取存储结构" class="headerlink" title="如何选取存储结构"></a>如何选取存储结构</h3><ul>
<li><p>基于存储考虑</p>
<p>难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</p>
</li>
<li><p>基于运算考虑</p>
<ul>
<li>若经常做的运算时按序号访问数据元素，则显然顺序表优于链表。</li>
<li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的。</li>
<li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</li>
</ul>
</li>
<li><p>基于环境的考虑</p>
<ul>
<li>顺序表容易实现，任何高级语言中都有数组类型；链表的操作时基于指针的，相对来讲，前者实现较为简单</li>
<li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表宜选择链式存储。</li>
</ul>
</li>
</ul>
<h2 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h2><h3 id="复习提示"><a href="#复习提示" class="headerlink" title="复习提示"></a>复习提示</h3><ul>
<li>本章通常以选择题的形式考查，题目不算难，但命题形式灵活，也容易出现在算法设计题中。</li>
<li>其中栈(出入栈的过程、出栈序列的合法性) 和 队列的操作及其特征是重点。</li>
<li>此外，栈和队列的顺序存储结构、链式存储结构及其特点、双端队列的特点、栈和队列的常见应用，以及数组和特殊矩阵的压缩存储都是读者必须掌握的内容。</li>
</ul>
<pre><code class="lang-mermaid">graph LR
    A(线性表)-- 操作受限 ---B1(栈)
    B1 --- B11(顺序栈)
    B1 --- B12(链栈)
    B1 --- B13(共享栈)
    A(线性表)-- 操作受限 ---B2(队列)
    B2 --- B21(循环队列)
    B2 --- B22(链式队列)
    B2 --- B23(双端队列)
    A-- 推广 ---C(数组)
    C --- C1(一维数组)
    C --- C2(&quot;多维数组: 压缩存储, 稀疏矩阵&quot;)
</code></pre>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈(Stack) 只允许在一端进行插入或删除操作的线性表。</p>
<ul>
<li><p>顺序栈</p>
<pre><code class="lang-CQL">#define MaxSize 50
typedef struct{
    Elemtype data[MaxSize];
    int top;
} SqStack;
</code></pre>
<ul>
<li>栈顶指针: S.top, 初始时设置S.top=-1; 栈顶元素: S.data[S.top]</li>
<li>进栈操作: 栈不满时，栈顶指针先加1，再送值到栈顶元素。</li>
<li>出栈操作: 栈非空时，先取栈顶元素值，再将栈顶指针减1。</li>
<li>栈空条件: S.top == -1;栈满条件: S.top == MaxSize-1; 栈长: S.top+1 </li>
</ul>
</li>
<li><p>共享栈</p>
<pre><code>两个顺序栈共享一个一维数组空间
- top0=-1时，0号栈为空， top1=MaxSize时1号栈为空
- 栈满，仅当两个栈顶指针相邻(top1 - top0)=1 时，判断为栈满。
</code></pre></li>
</ul>
<ul>
<li><p>链栈</p>
<pre><code>typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
} *LiStack;
</code></pre><ul>
<li>多个栈共享存储空间</li>
<li>不存在栈满上溢,通常采用单链表实现</li>
<li>规定所有操作都在表头进行</li>
</ul>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列(Queue) 只允许在表的一端进行插入，而在表的另一端进行删除</p>
<h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><pre><code class="lang-c">#define MaxSize 50
typedef struct{
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;
</code></pre>
<p>存在 <strong>假溢出</strong> 的现象</p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><pre><code>初始时: Q.font=Q.rear=0
队首指针进1: Q.front=(Q.front+1)%MaxSize
队尾指针进1: Q.rear=(Q.rear+1)%MaxSize
队列长度: (Q.rear+MaxSize-Q.front)%MaxSize
</code></pre><p>区分队满还是队空，三种处理方式:</p>
<ol>
<li><p>(普遍)牺牲一个存储单元来区分队空和队满，即队头指针在队尾指针的下一位置作为队满的标志</p>
<pre><code>队满条件: (Q.rear+1)%MaxSize==Q.front
队空条件: Q.front==Q.rear
</code></pre></li>
<li><p>类型中增设表示元素个数的数据成员</p>
<pre><code>队空条件: Q.size==0
队满条件: Q.size==MaxSize
队满队空都有Q.front==Q.rear
</code></pre></li>
<li><p>类型中增设tag数据成员，以区分是队满还是队空。</p>
<ol>
<li>tag等于0时，若因删除导致Q.front==Q.rear，则为队空。</li>
<li>tag等于1时，若因插入导致Q.front==Q.rear, 则为队满。</li>
</ol>
</li>
</ol>
<h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><pre><code class="lang-c">typedef struct{
    ElemType data;
    struct LinkNode *next;
} LinkNode;
typedef struct{
    LinkNode *front, *rear;
} LinkQueue;
</code></pre>
<ul>
<li>当Q.front==NULL 且Q.rear==NULL时, 链式队列为空</li>
<li>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</li>
</ul>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>输出受限的双端队列，输入受限的双端队列</p>
<ul>
<li>能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。4132</li>
<li>能由输出受限的双端队列得到，但不能有输入受限的双端队列得到的输出序列。4213</li>
<li>既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列。4231</li>
</ul>
<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><ul>
<li>栈在括号匹配中的应用</li>
<li>栈在表达式求值中的应用</li>
<li>栈在递归中的应用</li>
<li>队列在层次遍历中的应用</li>
<li>队列在计算机系统中的应用</li>
</ul>
<h3 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h3><p>即最小空间存储矩阵，矩阵在计算机图形学，工程计算中占有举足轻重的地位。数据结构考虑的是如何用最小的内存空间来存储同样一组数据，并能方便地提取矩阵中的元素。</p>
<p>数组一旦被定义，其维数和维界就不再改变。</p>
<ul>
<li>数组的存储结构<ul>
<li>一个数组的所有元素在内存中占用一段连续的存储空间。</li>
</ul>
</li>
<li>矩阵的压缩存储</li>
<li>稀疏矩阵</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在考研真题中，链式栈出现的概率要比顺序栈低得多。</p>
<h2 id="Tree-and-Binary-Tree"><a href="#Tree-and-Binary-Tree" class="headerlink" title="Tree and Binary Tree"></a>Tree and Binary Tree</h2><h3 id="复习提示-1"><a href="#复习提示-1" class="headerlink" title="复习提示"></a>复习提示</h3><ul>
<li>本章多以选择题的形式考查，但也会涉及树遍历相关的算法题</li>
<li>树和二叉树的性质、遍历操作、转换、存储结构和操作特性等</li>
<li>满二叉树、完全二叉树，线索二叉树、哈夫曼树的定义和性质</li>
<li>二叉排序树和二叉平衡树的性质和操作等，都是选择题必然会涉及的内容</li>
</ul>
<pre><code class="lang-mermaid">graph LR
    A(树形结构) --- B(二叉树)
    B --- B1(&quot;概念: 定义, 存储结构&quot;)
    B --- B2(&quot;操作&quot;)
    B --- B3(&quot;应用&quot;)
    B2 --- B21(&quot;三种遍历&quot;)
    B2 --- B22(&quot;线索二叉树&quot;)
    B3 --- B31(&quot;排序二叉树 ---- 平衡二叉树&quot;)
    B3 --- B32(哈夫曼树)
    A(树形结构) --- C(树和森林)
    C --- C1(&quot;概念: 定义, 存储结构&quot;)
    C --- C2(操作)
    C2 --- C21(与二叉树的转换)
    C2 --- C22(遍历)
    C --- C3(&quot;应用: 并查集&quot;)
</code></pre>
<p>树具有如下最基本的性质:</p>
<ol>
<li>树种的结点树等于所有结点的度数加 1。</li>
<li>度为 m 的树种第 i 层上至多有 $m^{i-1}$ 个结点。(i $\ge$ 1)</li>
<li>高度为 h 的 m 叉树至多有 $(m^h-1)/(m-1)$ 个结点</li>
<li>具有 n 个结点的 m 叉树的最小高度为 $\lceil log_m{(n(m-1)+1)} \rceil$</li>
</ol>
<p>树结点与度之间的关系有:</p>
<ol>
<li>总结点数 = $n_0+n_1+n_2+…+n_m$</li>
<li>总分支数 = $1n_1+2n_2+…+mn_m$</li>
<li>总结点数 = 总分支数  + 1</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li><p>几个特殊的二叉树</p>
<ul>
<li>满二叉树</li>
<li>完全二叉树</li>
<li>二叉排序树</li>
<li>平衡二叉树</li>
</ul>
</li>
<li><p>二叉树的性质</p>
<ul>
<li>$n_0=n_2+1$</li>
<li>非空二叉树上第 K 层上至多有 $2^{K-1}$个结点 $(k\ge1)$</li>
<li>高度为 h 的二叉树至多有 $2^h-1$ 个结点</li>
<li>具有 n 个 (n &gt; 0) 结点的完全二叉树的高度为 $\lceil log_2(n+1)\rceil 或 \lceil log_2n\rceil+1$</li>
</ul>
</li>
<li><p>顺序存储结构</p>
</li>
<li><p>链式存储结构</p>
<pre><code class="lang-c">typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;
</code></pre>
<ul>
<li>在含有 n 个结点的二叉链表中，含有 n + 1个空链域</li>
<li>非空指针树 = 总分支数 = n - 1</li>
<li>空指针树 = n + 1</li>
</ul>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>按照某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。</p>
<ul>
<li><p>common</p>
</li>
<li><p>由遍历序列构造二叉树, 先中，后中，层中</p>
</li>
<li><p>常见有: 先序(PreOrder)、中序(InOrder) 和后序(PostOrder)。</p>
<ul>
<li>时间复杂度都是O(n).</li>
<li>递归遍历中，递归工作栈的栈深恰好为树的深度。</li>
</ul>
</li>
<li><p>递归算法和非递归算法的转换</p>
<ul>
<li><p>借助栈</p>
<pre><code class="lang-c">void InOrder2(BiTree T){
    InitStack(S);
    BiTree p=T;
    while(p||!IsEmpty(s)) {
        if(p) {
            Push(S, p);
            p = p-&gt;lchild;
        } else {
            Pop(S, p);
            visit(p);
            p = p-&gt;rchild;
        }
    }
}
</code></pre>
</li>
</ul>
</li>
<li><p>层次遍历</p>
<ul>
<li><p>借助队列</p>
<pre><code class="lang-c">void LevelOrder(BiTree T) {
    InitQueue(Q);
    BiTree p;
    EnQueue(Q,T);
    while(!IsEmpty(Q)) {
        DeQueue(Q,p);
        visit(p);
        if (p-&gt;lchild != NULL)
            EnQueue(Q, p-&gt;lchild);
        if (p-&gt;rchild != NULL)
            EnQueue(Q, p-&gt;rchild);
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><ul>
<li><p>线索，指向前驱或后继的指针。</p>
<pre><code class="lang-c++">  typedef struct ThreadNode {
  ElemType data; 
      struct ThreadNode *lchild, *rchild; // 左右孩子指针
      int ltag, rtag;
  } ThreadNode, *ThreadTree;
</code></pre>
</li>
<li><p>线索二叉树的构造</p>
<p><img src="pat/dt_001.jpg" alt="dt_001"></p>
<pre><code class="lang-c++">void InThread(ThreadTree &amp;p, ThreadTree &amp;pre) {
    // 中序遍历对二叉树线索化的递归算法
    if (p != NULL) {
        InThread(p-&gt;lchild, pre);
        if (p-&gt;lchild == NULL) {
            p-&gt;lchild = pre;
            p-&gt;ltag = 1;
        }
        if (pre != NULL &amp;&amp; pre-&gt;rchild==NULL) {
            pre-&gt;rchild = p;
            pre-&gt;rtag = 1;
        }
        pre = p;
        InThread(p-&gt;rchild, pre);
    }
}

void CreateInThread(ThreadTree T) {
    ThreadTree pre=NULL;
    if (T != NULL) {
        InThread(T, pre);
        pre-&gt;rchild=NULL;
        pre-&gt;rtag=1;
    }
}
</code></pre>
<h3 id="树-森林"><a href="#树-森林" class="headerlink" title="树,森林"></a>树,森林</h3><ul>
<li><p>存储结构</p>
<ul>
<li><p>双亲表示法</p>
<pre><code class="lang-c++">#define MAX_TREE_SIZE 100
typedef struct {
    ElemType data;
    int parent;
} PTNode;
typedef struct {
    PTNode nodes[MAX_TREE_SIZE];
    int n;
}PTree;
</code></pre>
</li>
<li><p>孩子表示法</p>
</li>
<li><p>孩子兄弟表示法, 又称二叉树表示法</p>
<pre><code class="lang-c++">typedef struct CSNode {
    ElemType data;
    struct CSNode *firstchild, *nextsibling;
} CSNode, *CSTree
</code></pre>
<ul>
<li>最大的优点是可以方便地实现树转换为二叉树的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>树，森林和二叉树的转换</p>
</li>
<li><p>树和森林的遍历</p>
<ul>
<li>先根遍历</li>
<li>后根遍历</li>
</ul>
</li>
<li><p>树的应用 —— 并查集</p>
</li>
</ul>
</li>
</ul>
<h3 id="树和二叉树的应用"><a href="#树和二叉树的应用" class="headerlink" title="树和二叉树的应用"></a>树和二叉树的应用</h3><ul>
<li><p>二叉排序树 (BST)</p>
<ul>
<li><p>二叉排序树的非递归查找</p>
<pre><code class="lang-c++">BSTNode *BST_Search(BiTree T, ElemType key, BSTNode *&amp;p) {
    p=NULL;
    while (T!=NULL &amp;&amp; key!=T-&gt;data) {
        p=T;
        if (key &lt; T-&gt;data) T=T-&gt;lchild;
        else T=T-&gt;rchild;
    }
    return T;
}
</code></pre>
</li>
<li><p>二叉排序树的插入</p>
<pre><code class="lang-c++">int BST_Insert(BiTree &amp;T, KeyType k){
    if (T == NULL) {
        T = (BiTree)malloc(sizeof(BSTNode));
        T-&gt;key=k;
        T-&gt;lchild=T-&gt;rchild=NULL;
        return 1;
    } else if (k == T-&gt;key){
        return 0;
    } else if (k &lt; T-&gt;key)
        return BST_Insert(T-&gt;lchild, k);
}
</code></pre>
</li>
<li><p>二叉排序树的构造</p>
<pre><code class="lang-c++">void Create_BST(BiTree &amp;T, KeyType str[], int n) {
    T=NULL;
    int i=0;
    while(i&lt;n){
        BST_Insert(T,str[i]);
        i++;
    }
}
</code></pre>
</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<p>任意结点的左右子树高度差的绝对值不超过1，将这样的二叉树成为平衡二叉树，简称平衡树(AVL)。定义高度差为平衡因子，可能取值为-1,0,1。</p>
<ul>
<li><p>调整规律</p>
<ul>
<li>LL平衡旋转(右单旋转)</li>
<li>RR平衡旋转(左单旋转)</li>
<li>LR平衡旋转(先左后右双旋转)</li>
<li>RL平衡旋转(先右后左双旋转)</li>
</ul>
</li>
<li><p>平衡二叉树的查找</p>
<p>含有 n 个结点的平衡二叉树的最大深度为O($log_2{n}$)，因此平衡二叉树的平均查找长度为$O(log_2{n})$。</p>
</li>
</ul>
</li>
<li><p>哈夫曼树和哈夫曼编码</p>
<ul>
<li><p>common</p>
<ul>
<li><p>从树的根结点到任意结点的路径长度 (经过的边数)与该结点上权值的乘积，称为该结点的<strong>带权路径长度</strong>。</p>
</li>
<li><p>树种所有叶节点的<strong>带权路径长度</strong>之和称为该树的带权路径长度，记为$WPL=\sum<em>{i=1}^{n}w</em>{i}l_{i}$。</p>
<blockquote>
<p>$w_i是第i个叶节点所带的权值，l_i是该叶节点到根结点的路径长度$</p>
</blockquote>
</li>
<li><p>在含有n个带权叶子结点的二叉树中，其中带权路径长度(WPL) 最小的二叉树称为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong>。</p>
</li>
</ul>
</li>
<li><p>哈夫曼树的构造</p>
<ul>
<li>每个初始结点最终都成为叶节点，且权值越小的结点到跟结点的路径长度越大。</li>
<li>构建过程中共新建了$n-1$个结点，因此哈夫曼树种的结点总数为$2n-1$。</li>
</ul>
</li>
<li><p>哈夫曼编码</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本章的内容较多，其中二叉树是极其重要的考点。</li>
<li>遍历是二叉树的各种操作的基础，统考时会考察遍历过程中对结点的各种其他操作，而且容易结合递归算法和利用栈或队列的非递归算法。</li>
<li>读者需重点掌握各种遍历方法的代码书写，并学会在遍历的基础上，进行一些其他的相关操作。</li>
<li>其中递归算法短小精悍，出现的概率较大，请读者不要掉以轻心，要做到对几种遍历方式的程序模板烂熟于心，并结合一定数量的习题，才可以在考试中快速地写出漂亮的代码。</li>
</ul>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><p>图$G$由顶点集$V$和边集$E$组成，记为$G=(V，E)$。有向图$<v, w>: v为弧尾，w为弧头$。无向图$(v, w)$  </p>
<h3 id="复习提示-2"><a href="#复习提示-2" class="headerlink" title="复习提示"></a>复习提示</h3><ul>
<li>图算法的难度较大，因此主要掌握<strong>深度优先搜索</strong>与<strong>广度优先搜索</strong>，其他内容以算法题形式出现的概率不高。</li>
<li>应掌握<ul>
<li>图的基本概念及基本性质、</li>
<li>图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及其特性</li>
<li>存储结构之间的转化</li>
<li>基于存储结构上的遍历操作和各种应用(拓扑排序、最小生成树、最短路径和关键路径)</li>
</ul>
</li>
<li>图的相关算法较多、易混，但通常只要求掌握其基本思想和实现步骤(能手动模拟)，而算法的具体实现则不是重点</li>
</ul>
<pre><code class="lang-mermaid">graph LR
    A(图) --- B(图的定义)
    A(图) --- C(图结构的存储)
    C --- C1(&quot;邻接矩阵法, 邻接表法&quot;)
    C --- C2(&quot;邻接多重表法, 十字链表&quot;)
    A(图) --- D(图的遍历)
    D --- D1(深度优先遍历)
    D --- D2(广度优先遍历)
    A(图) --- E(图的相关应用)
    E --- E1(&quot;最小生成树: Prim算法, Kruskal算法&quot;)
    E --- E2(&quot;最短路径: Dijkstr算法, Floyd算法&quot;)
    E --- E3(&quot;拓扑排序: AOV网&quot;)
    E --- E4(&quot;关键路径: AOE网&quot;)
</code></pre>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>有向图，无向图，简单图，多重图，完全图(简单完全图)，子图，</p>
</li>
<li><p>连通，连通图和连通分量</p>
<ul>
<li>无向图中，顶点 $v$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是<strong>连通的</strong>。</li>
<li>无向图中，若图$G$中任意两个顶点都是连通额，则称图$G$为<strong>连通图</strong>。</li>
<li>无向图中的极大连通子图称为<strong>连通分量</strong>。极大即要求该连通子图包含其所有的边，<strong><em>极小连通子图</em></strong>  是既要保持图连通又要使得边数最少的子图。</li>
</ul>
</li>
<li><p>强连通图、强连通分量</p>
<ul>
<li>有向图中，$v 到 w ，w 到 v$ 都有路径，则称两个顶点是<strong>强连通的</strong>。</li>
<li>有向图中，图中任意一对顶点都是强连通的，则称此图为<strong>强连通图</strong>。</li>
<li>有向图中的极大强连通子图称为有向图的<strong>强连通分量</strong></li>
</ul>
</li>
<li><p>生成树、生成森林</p>
<ul>
<li><p>连通图的<strong>生成树</strong>包含图中全部顶点的一个极小连通子图，若顶点数为 $n$，则它的生成树含有 $n-1$ 条边。</p>
</li>
<li><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p>
</li>
</ul>
</li>
<li><p>[顶点的度、入度和出度]</p>
</li>
<li><p>边的权和网、[稠密图、稀疏图]、[路径、路径长度和回路]、[简单路径、简单回路]、距离、有向树</p>
</li>
</ul>
<h3 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h3><ul>
<li><p>临接矩阵法，指用一个一维数组存储图中顶点信息，用一个二维数组存储图中边的信息(即各顶点之间的临接关系)，存储顶点之间临接关系的二维数组称为邻接矩阵。</p>
<pre><code class="lang-c++">#define MaxVertexNum 100                        // 图顶点数目的最大值
typedef char VertexType;                        // 顶点的数据类型
typedef int EdgeType;                            // 带权图中边上权值的数据类型
typedef struct {
    VertexType Vex[MaxVertexNum];                // 顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];    // 邻接矩阵，边表
    int vexnum, arcnum;                            // 图的当前顶点数和弧数
} MGraph;
</code></pre>
<ul>
<li>邻接矩阵表示法的空间复杂度为$O(n^2)$，其中 n 为图的顶点数$\vert V \vert$</li>
<li>1 为存在边，0 为不存在边 </li>
</ul>
</li>
<li><p>邻接表法，是对图$G$中的每个顶点$v_i$建立一个单链表，这个单链表称为边表。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表）。</p>
<p><img src="pat/dt_508.jpg" alt=""></p>
<pre><code class="lang-c++">#define MaxVertexNum 100        // 图中顶点数目的最大值
typedef struct ArcNode {        // 边表结点
    int adjvex;                    // 该弧所指向的顶点的位置
    struct ArcNode *next;        // 指向下一条弧的指针
    // InfoType info;            // 网的边权值
}ArcNode;
typedef struct VNode {            // 顶点表结点
    VertexType data;            // 顶点信息
    ArcNode *first;                // 指向第一条依附该顶点的弧的指针
}VNode, AdjList[MaxVertexNum];
typedef struct {
    AdjList vertices;            // 邻接表
    int vexnum, arcnum;            // 图的顶点数和弧数
} ALGraph;                        // ALGraph是以邻接表存储的图类型
</code></pre>
<ul>
<li>顶点表结点 [ 顶点域(data)，边表头指针(firstarc) ]，边表结点 [ 邻接点域(adjvex)，指针域(nextarc)]</li>
</ul>
</li>
<li><p>十字链表，是有向图的一种链式存储结构</p>
<p><img src="pat/dt_509.jpg" alt=""></p>
<pre><code class="lang-c++">#define MaxVertexNum 100            // 图中顶点数目的最大值
typedef struct ArcNode {            // 边表结点
    int tailvex, headvex;            // 该弧的头尾结点
  struct AcrNode *hlink, *tlink;    // 分别指向弧头相同和弧尾相同的结点
    // InfoType info;                // 相关信息指针
} ArcNode;
typedef struct VNode {                // 顶点表结点
    VertexType data;                // 顶点信息
    ArcNode *firstin, *firstout;    // 指向第一条入弧和出弧
} VNode;
typedef struct {
    VNode xlist[MaxVertexNum];        // 邻接表
    int vexnum, arcnum;                // 图的顶点数和弧数
} GLGraph;                            // GLGraph 是以十字邻接存储的图类型
</code></pre>
<ul>
<li>顶点结点 [data，firstin，firstout]</li>
<li>弧结点 [tailvex，headvex，hlink，tlink，info]</li>
</ul>
</li>
<li><p>邻接多重表，是无向图的另一种链式存储结构。</p>
<p><img src="pat/dt_510.jpg" alt=""></p>
<pre><code class="lang-c++">#define MaxVertexNum 100            // 图中顶点数目的最大值
typedef struct ArcNode {            // 边结点
    bool mark;                        // 访问标记
    int ivex, jvex;                    // 分别指向该弧的两个结点
    struct ArcNode *ilink, *jlink;    // 分别指向两个顶点的下一条边
    // InfoType info;                // 相关信息指针
} ArcNode;        
typedef struct VNode {
    VertexType data;                // 顶点表结点
    ArcNode *firstedge;
} VNode;
typedef struct {
    VNode adjmulist[MaxVertexNum];
    int vexnum, arcnum;
} AMLGraph;
</code></pre>
<ul>
<li>顶点结点 [data，firstedge]</li>
<li>边结点 [mark，ivex，ilink，jvex，jlink，info]</li>
</ul>
</li>
<li><p>图的基本操作</p>
<ul>
<li>Adjacent(G, x, y)</li>
<li>Neighbors(G, x)</li>
<li>InsertVertex(G, x)</li>
<li>DeleteVertex(G, x)</li>
<li>AddEdge(G, x, y)</li>
<li>RemoveEdge(G, x, y)</li>
<li>FirstNeighbor(G, x):  存在，返回顶点号，不存在，返回 -1.</li>
<li>NextNeighbor(G, x, y):  存在，返回顶点号，不存在，返回 -1.</li>
<li>Get_edge_value(G, x, y)</li>
<li>Set_edge_value(G, x, y, v)</li>
</ul>
</li>
</ul>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul>
<li>Intro<ul>
<li>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。</li>
<li>树是一种特殊的图。</li>
<li>几乎所有图的搜索算法，都可以抽象为优先级搜索或最佳优先搜索。</li>
</ul>
</li>
<li><p>对于同样一个图，基于邻接矩阵存储的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS和BFS序列是不唯一的。</p>
</li>
<li><p>广度优先搜索，(Breadth-First-Search, BFS)</p>
<ul>
<li><p>info</p>
<ul>
<li>会优先考虑最早被发现的顶点，也就是离起点越近的顶点其优先级越高。</li>
<li>类似于二叉树的层序遍历算法，借助队列。</li>
<li>Dijkstra 单源最短路径算法和 Prim最小生成树算法也应用了类似的思想。</li>
<li>图的广度优先遍历还可用于求一些问题的最优解，但初试方面很难涉及。</li>
<li>邻接表存储$O(\vert V \vert+\vert E \vert)$；邻接矩阵存储$O(\vert V \vert^2)$。</li>
<li>在广度遍历的过程中，我们可以得到一颗遍历树，称为广度优先生成树。</li>
</ul>
</li>
<li><p>广度优先所有算法的伪代码如下：</p>
<pre><code class="lang-c++">bool visited[MAX_VERTEX_NUM];
void BFSTraverse(Graph G) {
    // 对图G进行广度优先遍历，设访问函数为visit()
    for (i=0; i&lt;G.vexnum; ++i)        
        visited[i] = false;                // 访问标记数组初始化
    InitQueue(Q);                        // 初始化辅助队列Q
    for (i=0; i&lt;G.vexnum; ++i)            // 从 0 号顶点开始遍历
        if (!visited[i])                // 对每个连通分量调用一次BFS
            BFS(G, i);                    // Vi未访问过，从Vi开始BFS
}
void BFS(Graph G, int v) {
    visit(v);                            // 访问初始顶点v
    visited[v] = true;                    // 对v做已访问标记
    Enqueue(Q, v);                        // 顶点 v 入队列
    while(!isEmpty(Q)) {
        DeQueue(Q, v);                    // 顶点 v 出队列
        for (w=FirstNeighbor(G, v); w&gt;=0; w=NextNeighbor(G, v, w)
                                         // 检测 v 所有邻接点
             if (!visited[w]) {            // w 为 v 的尚未访问的邻接顶点
                 visit(w);                // 访问顶点 w
                 visited[w] = true;        // 对w做已访问标记
                 EnQueue(Q, w);
             } //if
    } // while
}
</code></pre>
</li>
<li><p>BFS算法求解单源最短路径问题(最少边数，非带权)</p>
<pre><code class="lang-c++">void BFS_MIN_Distance(Graph G, int u) {
    //d[i]表示从 u 到 i 结点的最短路径
    for (i=0; i&lt;G.vexnum; ++i)
        d[i] = ∞;                        // 初始化路径长度
    visited[u] = true; d[u] = 0;
    EnQueue(Q, u);
    while(!isEmpty(Q)) {                // BFS算法主过程
        DeQueue(Q, u);                    // 队头元素出队
        for (w=FirstNeighbor(G, u); w&gt;=0; w=NextNeighbor(G, u, w))
            if (!visited[w]) {            // w为u的尚未访问的邻接顶点
                visited[w] = true;        // 设已访问标记
                d[w] = d[u] + 1;        // 路径长度加1
                EnQueue(Q, w);            // 顶点w入队
            } // if
    } //while
}
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>深度优先搜索 (Depth-First-Search, DFS)</p>
<ul>
<li><p>info</p>
<ul>
<li>会优先考虑最后被发现的顶点，广泛应用于人工智能方面。</li>
<li>类似于树的先序遍历(借助递归工作栈)，所遵循的策略是尽可能”深”地搜索一个图。</li>
<li>邻接矩阵 $O(\vert V \vert^2)$；邻接表 $\vert V \vert+\vert E \vert$ 。</li>
<li>对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林。</li>
</ul>
</li>
<li><p>算法过程如下</p>
<pre><code class="lang-c++">bool visited[MAX_VERTEX_NUM];            // 访问标记数组
void DFSTraverse(Graph G) {
    // 对图G进行深度优先遍历，访问函数为visit()
    for (v=0; v&lt;G.vexnum; ++v)
        visited[v] = false;
       for (v=0; v&lt;G.vexnum; ++v)
        if (!visited[v])
            DFS(G, V);
}
void DFS(Graph G, int v) {
    // 从顶点 v 出发, 采用递归思想，深度优先遍历图G
    visit(v);                            // 访问顶点
    visited[v] = true;                    // 设已访问标记
    for (w=FirstNeighbor(G, v); w&gt;=0; w=NextNeighbor(G, v, w))
        if (!visited[w]) {                // w 为 u 的尚未访问的邻接顶点
            DFS(G, w);
            // if 
        }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><p>本节是历年考查重点。图的应用主要包括: 最小生成(代价)树，最短路径，拓扑排序和关键路径。一般，直接以算法设计题形式考查的可能性很小，而更多的是结合图的实例来考查算法的具体执行过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。</p>
<ul>
<li><p>最小生成树</p>
<ul>
<li>性质：不唯一；边的权值之和唯一；边数为顶点数减1</li>
<li>算法：Prim(普里姆)，适于求解边稠密的图的最小生成树。</li>
<li>算法：Kruskal(克鲁斯卡尔)，是一种按权值的递增次序选择合适的边来构成最小生成树的方法，适于边稀疏而顶点多的图。</li>
</ul>
</li>
<li><p>最短路径，带权路径长度最短的那条路径称为最短路径。</p>
<ul>
<li>Dijkstra。<ul>
<li>常用于求解带权有向图中某个源点到其余各顶点的最短路径。</li>
<li>基于贪心算法</li>
</ul>
</li>
<li>Floyd-Warshall。</li>
</ul>
</li>
<li><p>拓扑排序</p>
<ul>
<li><p>Info</p>
<ul>
<li>有向无环图，简称DAG图。</li>
<li>AOV网，DAG图中，顶点表示活动，有向边表示活动的先后关系。</li>
<li>拓扑排序是对有向无环图的顶点的一种排序。</li>
<li>对一般图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。</li>
</ul>
</li>
<li><p>算法实现</p>
<pre><code class="lang-c++">bool TopologicalSort(Graph G) {
    // 若G存在拓扑序列，返回true; 否则返回false,这时 G 中存在环
    InitStack(S);                            // 初始化栈，存储入度为0的顶点
    for (int i=0; i&lt;G.vexnum; i++)
        if (indegree[i]==0)
            Push(S, i);                        // 将所有入度为 0 的顶点进栈
    int count = 0;                            // 计数，记录当前已经输出的顶点数
    while(!IsEmpty(S)) {                    // 栈不空，则存在入度为 0 的顶点
        Pop(S, i);                            // 栈顶元素出栈
        print[count++]=i;                    // 输出顶点 i.
        for (p=G.vertices[i].firstarc; p ; p=p-&gt;nextarc) {
            // 将所有 i 指向的顶点的入度间1，并且将入度减为0的顶点压入栈 S
            v = p-&gt;adjvex;
            if (!(--indegree[v]))
                Push(S, v);                    // 入度为0， 则入栈
        } // for
    } // while
    if (count&lt;G.vexnum)
        return false;                        // 排序失败，有向图中有回路
    else
        return true;                        // 拓扑排序成功
}
</code></pre>
</li>
</ul>
</li>
<li><p>关键路径</p>
<ul>
<li><p>Info</p>
<ul>
<li>在带权有向图中，顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销(如完成活动所需的时间)，则称这种有向图为用边表示活动的网络，简称AOE网。</li>
<li>性质<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。</li>
<li>只有在进入某一顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li>
</ul>
</li>
<li>AOE网中，仅有一个入度为0的顶点(开始顶点，源点)，也仅有一个出度为0的顶点(结束顶点，汇点)</li>
<li>AOE网中具有最大路径长度的路径称为<strong>关键路径</strong>，关键路径上的活动称为关键活动。</li>
<li>AOE网中的路径并不唯一，关键路径上的活动都是关键活动，决定整个过程的关键因素。</li>
</ul>
</li>
<li><p>寻找关键活动时所用到的几个参量的定义。</p>
<ol>
<li><p>事件$v_k$的最早发生事件$v_e(k)$</p>
<p>$v_e(源点)=0$</p>
<p>$v_e(k)=Max{v_e(j)+Weight(v_j, v_k)}, Weight(v_j, v_k)表示<v_j, v_k>上的权值$</p>
</li>
<li><p>事件$v_j$的最迟发生事件$v_l(j)$</p>
<p>$v_l(汇点)=v_e(汇点)$</p>
<p>$v_l(j)=Min{v_l(k)-Weight(v_j, v_k)}, Weight(v_j, v_k)表示<v_j, v_k>上的权值$</p>
</li>
<li><p>活动$a_i$的最早开始事件$e(i)$</p>
<p>该时间是指该活动的起点所表示的事件最早发生的时间。</p>
<p>若边$<v_k,vj>$表示活动$a_i$，则有$e(i)=v_e(k)$</p>
</li>
<li><p>活动$a_i$的最迟开始事件$l(i)$</p>
<p>该时间是指该活动的终点所表示的事件最迟发生时间与该活动所需时间之差。</p>
<p>若边$<v_k,v_j>$表示活动$a<em>i$，则有$l</em>(i)=v_l(j)-Weight(v_k,v_j)$</p>
</li>
<li><p>一个活动$a_i$的最迟开始时间$l(i)$和其最早开始时间$e(i)$的差额$d(i)=l(i)-e(i)$</p>
<p>它是指该活动的时间余量，即活动$a_i$可拖延的时间。</p>
<p>称$l(i)-e(i)=0$即$l(i)=e(i)$的活动$a_i$是关键活动。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h2><h3 id="复习提示-3"><a href="#复习提示-3" class="headerlink" title="复习提示"></a>复习提示</h3><p>本章是考研命题的终点</p>
<ul>
<li>对应散列查找，应掌握散列表的构造、冲突处理方法(各种方法的处理过程)、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。</li>
<li>对于折半查找，应掌握折半查找的过程、构造判定树、分析查找成功和查找失败的平均查找长度等</li>
<li>B树和B+ 树是本章的难点，对于B树，考纲要求掌握插入、删除和查找的操作过程，不要求掌握算法；对于B+ 树，仅要求了解其基本概念和性质。</li>
<li>串部分需要重点掌握next数组的构造方法。</li>
</ul>
<pre><code class="lang-mermaid">graph LR
    A(查找) --- B(&quot;基本概念: 静态查找, 动态查找&quot;)
    A --- C(线性结构)
    C --- C1(顺序查找)
    C --- C2(折半查找)
    C --- C3(分块查找)
    A --- D(树形结构)
    D --- D1(二叉排序树)
    D --- D2(二叉平衡树)
    D --- D3(B树, B+树)
    A --- E(&quot;散列结构 ---- 散列表&quot;)
    E --- E1(性能分析)
    E --- E2(冲突处理)
    A --- F(&quot;效率指标 --- 平均查找长度&quot;)
    F --- F1(查找成功)
    F --- F2(查找失败)
</code></pre>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>查找，查找表，</li>
<li>静态查找：顺序查找，折半查找，散列查找等</li>
<li>动态查找：二叉排序树的查找，散列查找。（二叉平衡树和B树都是二叉排序树的改进）</li>
<li>关键字，平均查找长度(ASL，衡量查找算法效率的最主要的指标)</li>
</ul>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>又称线性查找，主要用于在线性表中进行查找。</p>
<ul>
<li><p>一般线性表的顺序查找</p>
<pre><code class="lang-c++">typedef struct {
    ElemType *elem;        // 元素存储空间基址，建表时按实际长度分配，0号单元留空
    Int TableLen;
}SSTable;
int Search_Seq(SSTable ST, ElemType key) {
    ST.elem[0] = key;
    for (i=ST.TableLen;ST.elem[i]!=key;--i);
    return i;
}
</code></pre>
<ul>
<li>ST.elem[0] = key 称为 “哨兵”，可以避免很多不必要的判断语句，从而提高程序效率。</li>
<li>$ASL<em>{成功}=\frac{n+1}{2}\qquad ASL</em>{不成功}=n+1$</li>
<li>缺点: 当 n 较大时，平均查找长度较大，效率低。</li>
<li>优点: 对数据元素的存储没有要求，顺序存储或链式存储皆可。</li>
<li>注意：对线性链表只能进行顺序查找。</li>
</ul>
</li>
<li><p>有序表的顺序查找</p>
<ul>
<li>$ASL<em>{成功}=\frac{n+1}{2}; ASL</em>{不成功}=\frac{n}{2}+\frac{n}{n+1}$</li>
<li>比一般的顺序查找算法好一些</li>
<li>注意：有序表的顺序查找和后面的折半查找的思想是不一样的，且有序表的顺序查找中的线性表可以是链式存储结构。</li>
</ul>
</li>
</ul>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>又称二分查找，仅适用于有序的顺序表。</p>
<ul>
<li><p>算法</p>
<pre><code class="lang-c++">int Binary_Search(SeqList L, ElemType key) {
    int low=0, high=L.Tablelen-1, mid;
    while (low&lt;=high) {
        mid=(low+high)/2;
        if (L.elem[mid] == key)
            return mid;
        else if (L.elem[mid] &gt; key)
            high=mid-1;
        else
            low=mid+1;
    }
    return -1;
}
</code></pre>
<ul>
<li>$ASL\approx log_2(n+1)-1$，判定树种的树高$h=\lceil log_2(n+1) \rceil$</li>
<li>即$O(log_2n)$，平均情况下比顺序表查找的效率高。</li>
<li>折半查找仅适用于线性表的顺序存储结构，不适合与链式存储结构，且要求元素按关键字有序排列。</li>
</ul>
</li>
</ul>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><ul>
<li><p>又称索引顺序查找，结合顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p>
</li>
<li><p>块内无序，块间有序</p>
</li>
<li>分为两步<ol>
<li>在索引表中确定待查记录所在的块，可以顺序或折半查找索引表。</li>
<li>在块内顺序查找。</li>
</ol>
</li>
</ul>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h2 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><h3 id="复习提示-4"><a href="#复习提示-4" class="headerlink" title="复习提示"></a>复习提示</h3><ul>
<li>堆排序（建堆、插入和调整）、快速排序（划分、过程特征）、归并排序（归并路数、归并过程）是重点。</li>
<li>读者应深入掌握各种排序算法的思想、排序过程(能动手模拟) 和特征（初态的影响、时空复杂度、稳定性、适用性等）</li>
<li>常以选择题的形式考查不同算法之间的对比</li>
<li>对于一些常用排序算法的关键代码，要达到熟练编写的程度；</li>
<li>看到某特定序列，读者应具有选择最优排序算法（根据排序算法特征）的能力。</li>
</ul>
<pre><code class="lang-mermaid">graph LR
    A(排序) --- B(基本概念)
    B --- B1(稳定性)
    B --- B2(&quot;衡量标准: 时,空复杂度&quot;)
    A --- C(内部排序)
    C --- C1(插入排序)
    C1 --- C11(直接插入排序)
    C1 --- C12(折半插入排序)
    C1 --- C13(希尔排序)
    C --- C2(交换排序)
    C2 --- C21(冒泡排序)
    C2 --- C22(快速排序)
    C --- C3(选择排序)
    C3 --- C31(简单选择排序)
    C3 --- C32(堆排序)
    C --- C4(归并排序)
    C --- C5(基数排序)
    A --- D(&quot;外部排序----多路归并排序&quot;)
</code></pre>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li><p>直接插入排序</p>
<pre><code class="lang-c++">void InsertSort(ElemType A[], int n) {
    int i,j;
    for (i=2; i&lt;=n; i++) {                // 依次将A[2] ~ A[n]插入到前面已排序序列
        if (A[i].key &lt; A[i-1].key) 
            A[0]=A[i];
            for (j=i-1; A[0].key &lt; A[j].key; --j)
                A[j+1]=A[j];            // 向后挪位
            A[j+1]=A[0];
        }
}
</code></pre>
</li>
<li><p>折半插入排序</p>
<pre><code class="lang-c++">void InsertSort(ElemType A[], int n) {
    int i,j,low,high,mid;
    for (i=2; i&lt;=n; i++) {                // 依次将A[2] ~ A[n]插入到前面已排序序列
        A[0]=A[i];
        low=1; high=i-1;
        while (low &lt;= high) {
            mid=(low+high)/2;
            if (A[mid].key &gt; A[0].key) high=mid-1;
            else low=mid+1;
        }
        for (j=i-1; j&gt;=high+1; --j)
            A[j+1]=A[j];
        A[high+1]=A[0];
    }
}
</code></pre>
</li>
<li><p>希尔排序</p>
<pre><code class="lang-c++">void ShellSort(ElemType A[], int n) {
    for (dk=n/2; dk&gt;=1; dk=dk/2)
        for (i=dk+1; i&lt;=n; ++1) 
            if(A[i].key &lt; A[i-dk].key) {
                 A[0]=A[i];
                for (j=i-dk; j&gt;0&amp;&amp;A[0].key &lt; A[j].key; j-=dk)
                    A[j+dk]=A[j];
                A[j+dk]=A[0];
            }//if
}
</code></pre>
</li>
</ul>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ul>
<li><p>冒泡排序</p>
<pre><code class="lang-c++">void BubbleSort(ElemType A[], int n) {
    for (i=0; i&lt;n-1; i++) {
        flag=false;
        for(j=n-1; j&gt;i; j--)
            if (A[j-1].key &gt; A[j].key) {
                swap(A[j-1], A[j]);
                flag=true;
            }
        if (flag==false)
            return;
    }
}
</code></pre>
</li>
<li><p>快速排序</p>
<pre><code class="lang-c++">void QuickSort(ElemType A[], int low, int high) {
    if (low&lt;high) {
        int pivotpos=Partition(A, low, high);
        QuickSort(A, low, pivotpos-1);
        QuickSort(A, pivotpos+1, high);
    }
}
int partition(ElemType A[], int low, int high) {
    ElemType pivot=A[low];
    while(low&lt;high) {
        while(low&lt;high&amp;&amp;A[high] &gt;= pivot) --high;
        A[low]=A[high];
        while(low&lt;high&amp;&amp;A[low] &lt;= pivot) ++low;
        A[high]=A[low];
    }
    A[low]=pivot;
    return low;
}
</code></pre>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li><p>简单选择排序</p>
<pre><code class="lang-c++">void SelectSort(Ele;mType A[], int n) {
    for (i=0; i&lt;n-1; i++) {
        min = 1;
        for(j=i+1; j&lt;n; j++)
            if(A[j] &lt; A[min]) min=j;
        if(min!=i) swap(A[i], A[min])
    }
}
</code></pre>
</li>
<li><p>堆排序</p>
<ul>
<li><p>建立大根堆算法</p>
<pre><code class="lang-c++">void BuildMaxHeap(ElemType A[], int len) {
    for (int i=len/2; i&gt;0; i--)
        AdjustDown(A, i, len);
}
void AdjustDown(ElemType A[], int k, int len) {
    A[0]=A[k];
    for (i=2*k; i&lt;=len; i*=2) {
        if (i&lt;len &amp;&amp; A[i]&lt;A[i+1])
            i++;
        if (A[0]&gt;=A[i]) break;
        else {
            A[k]=A[i];
            k=i;
        }
    } // forj
    A[k]=A[0];
}
</code></pre>
</li>
<li><p>堆排序算法</p>
<pre><code class="lang-c++">void HeapSort(ElemType A[], int len) {
    BuildMaxHeap(A, len);
    for(i=len; i&gt;1; i--) {
        Swap(A[i], A[1]);
        AjustDown(A, 1, i-1);
    }//for
}
</code></pre>
</li>
<li><p>下面是向上调整堆的算法</p>
<pre><code class="lang-c++">void AjustUp(ElemType A[], int k) {
    A[0]=A[k];
    int i=k/2;
    while(i&gt;0&amp;&amp;A[i]&lt;A[0]) {
        A[k]=A[i];
        k=i;
        i=k/2;
    }//while
    A[k]=A[0];
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="各种内部排序算法的比较和应用"><a href="#各种内部排序算法的比较和应用" class="headerlink" title="各种内部排序算法的比较和应用"></a>各种内部排序算法的比较和应用</h3><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h1 id="Principles-of-Computer-Composition"><a href="#Principles-of-Computer-Composition" class="headerlink" title="Principles of Computer Composition"></a>Principles of Computer Composition</h1><h2 id="大纲-1"><a href="#大纲-1" class="headerlink" title="大纲"></a>大纲</h2><h3 id="考查目标-1"><a href="#考查目标-1" class="headerlink" title="[考查目标]"></a>[考查目标]</h3><p>1。理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，<br>具有完整的计算机系统的整机概念。<br>2。理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结<br>构的基本知识和基本实现方法。<br>3。能够综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论<br>和实际问题进行计算、分析，对一些基本部件进行简单设计；并能对高级程序设计语言（如<br>C 语言）中的相关问题进行分析。</p>
<h3 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h3><p>（一）计算机发展历程<br>（二）计算机系统层次结构</p>
<ol>
<li>计算机系统的基本组成</li>
<li><p>计算机硬件的基本组成</p>
</li>
<li><p>计算机软件和硬件的关系</p>
</li>
<li><p>计算机的工作过程</p>
</li>
</ol>
<p>（三）计算机性能指标<br>吞吐量、响应时间；CPU 时钟周期、主频、CPI、CPU 执行时间；MIPS、MFLOPS 、GFLOPS、<br>TFLOPS、PFLOPS。</p>
<h3 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h3><p>（一）数制与编码<br>1。进位计数制及其相互转换<br>2。真值和机器数<br>3.BCD 码</p>
<ol>
<li>字符与字符串<br>5。校验码<br>（二）定点数的表示和运算<br>1。定点数的表示<br>无符号数的表示；有符号整数的表示。<br>2。定点数的运算<br>定点数的位移运算；原码定点数的加减运算；补码定点数的加/减运算；定点数的乘/<br>除运算；溢出概念和判别方法。<br>（三）浮点数的表示和运算<br>1。浮点数的表示<br>IEEE 754 标准<br>2。浮点数的加/减运算<br>（四）算术逻辑单元 ALU<br>1。串行加法器和并行加法器<br>2。算术逻辑单元 ALU 的功能和结构</li>
</ol>
<h3 id="三、存储器层次结构"><a href="#三、存储器层次结构" class="headerlink" title="三、存储器层次结构"></a>三、存储器层次结构</h3><p>（一）存储器的分类<br>（二）存储器的层次化结构<br>（三）半导体随机存取存储器<br>1.SRAM 存储器<br>2.DRAM 存储器<br>3。只读存储器<br>4.Flash 存储器<br>（四）主存储器与 CPU 的连接<br>（五）双口 RAM 和多模块存储器<br>（六）高速缓冲存储器（Cache）<br>1.Cache 的基本工作原理<br>2.Cache 和主存之间的映射方式<br>3.Cache 中主存块的替换算法<br>4.Cache 写策略<br>（七）虚拟存储器<br>1。虚拟存储器的基本概念<br>2。页式虚拟存储器<br>3。段式虚拟存储器<br>4。段页式虚拟存储器<br>5.TLB（快表）</p>
<h3 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h3><p>（一）指令格式<br>1。指令的基本格式<br>2。定长操作码指令格式<br>3。扩展操作码指令格式<br>（二）指令的寻址方式<br>1。有效地址的概念<br>2。数据寻址和指令寻址<br>3。常见寻址方式<br>（三）CISC 和 RISC 的基本概念</p>
<h3 id="五、中央处理器（CPU）"><a href="#五、中央处理器（CPU）" class="headerlink" title="五、中央处理器（CPU）"></a>五、中央处理器（CPU）</h3><p>（一）CPU 的功能和基本结构<br>（二）指令执行过程<br>（三）数据通路的功能和基本结构<br>（四）控制器的功能和工作原理<br>1、硬布线控制器<br>2、微程序控制器<br>微程序、微指令和微命令；微指令的编码方式；微地址的形式方式。<br>（五）指令流水线<br>1、指令流水线的基本概念<br>2、指令流水线的基本实现<br>3、超标量和动态流水线的基本概念</p>
<h3 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h3><p>（一）总线概述<br>1、总线的基本概念<br>2、总线的分类<br>3、总线的组成及性能指标<br>（二）总线仲裁<br>1、集中仲裁方式<br>2、分布仲裁方式<br>（三）总线操作和定时<br>1、同步定时方式<br>2、异步定时方式<br>（四）总线标准</p>
<h3 id="七、输入输出（I-O）系统"><a href="#七、输入输出（I-O）系统" class="headerlink" title="七、输入输出（I/O）系统"></a>七、输入输出（I/O）系统</h3><p>（一）I/O 系统基本概念<br>（二）外部设备<br>1、输入设备：键盘、鼠标<br>2、输出设备：显示器、打印机<br>3、外存储器：硬盘存储器、磁盘阵列、光盘存储器<br>（三）I/O 接口（I/O 控制器）<br>1、I/O 接口的功能和基本结构<br>2、I/O 端口及其编址<br>（四）I/O 方式<br>1、程序查询方式<br>2、程序中断方式<br>中断的基本概念；中断响应过程；中断处理过程；多重中断和中断屏蔽的概念。<br>3、DMA 方式<br>DMA 控制器的组成，DMA 传送过程。</p>
<h2 id="一、计算机系统概述-1"><a href="#一、计算机系统概述-1" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><h3 id="复习提示-5"><a href="#复习提示-5" class="headerlink" title="复习提示"></a>复习提示</h3><blockquote>
<p>重点掌握各个性能指标的计算和基本概念。</p>
</blockquote>
<p><img src="pat/b001.jpg" alt=""></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>小记</p>
<ul>
<li>机器语言是计算机唯一可以直接执行的语言。</li>
</ul>
<p>英文缩写</p>
<ul>
<li><p>存储器</p>
<ul>
<li>MAR - 地址寄存器，多少个存储单元，即为内存</li>
<li>MDR - 数据寄存器，64k x 32位，即为存储容量</li>
</ul>
</li>
<li><p>运算器</p>
<ul>
<li>ALU - 算术逻辑单元</li>
<li>ACC - 累加器</li>
<li>MQ - 乘商寄存器</li>
<li>X - 操作数寄存器</li>
<li>IX - 变址寄存器</li>
<li>BR - 基址寄存器</li>
<li>PSW - 程序状态寄存器</li>
</ul>
</li>
<li>控制器<ul>
<li>PC - 程序计数器</li>
<li>IR - 指令寄存器，OP-操作码，Ad - 地址码</li>
<li>CU - 控制单元</li>
</ul>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li><p>机器字长，计算机能直接处理的二进制数据的位数，一般等于内部寄存器的大小，决定计算机的运算精度。</p>
</li>
<li><p>数据通路带宽，数据总线一次所能并行传送信息的位数。（外部）</p>
</li>
<li><p>主存容量，指主存储器所能存储信息的最大容量，MAR的位数反映存储单元的个数。</p>
</li>
<li><p>运算速度</p>
<ul>
<li><p>吞吐量，指系统在单位时间内处理请求的数量。主要取决于主存的存取周期</p>
</li>
<li><p>响应时间，</p>
</li>
<li><p>CPU时钟周期，常为节拍脉冲或T周期，即主频的倒数，是CPU中最小的时间单位，每个动作至少需要1个时钟周期。</p>
</li>
<li><p>主频（CPU时钟频率），衡量机器速度的重要参数，主频越高，速度越快。1Hz表示每秒1次。</p>
</li>
<li><p>CPI（Clock cycle Per Instruction），指执行一条指令所需的时钟周期数。</p>
</li>
<li><p>CPU执行时间，指运行一个程序所花费的时间</p>
<p>CPU执行时间=CPU时钟周期数 / 主频=（指令条数 x CPI）/ 主频</p>
</li>
<li><p>MIPS、MFLOPS(百万)、GFLOPS(十亿)、TFLOPS(万亿)</p>
</li>
</ul>
</li>
</ul>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul>
<li>计算机的功能部件</li>
</ul>
<p><img src="pat\cc0001.png" alt="image-20200409090700853"></p>
<ul>
<li><p>三种语言</p>
<p>机器语言，汇编语言(汇编程序)，高级语言(编译-汇编 | 翻译)</p>
</li>
<li><p>计算机的工作过程</p>
<pre><code>取指令：(PC) -&gt; MAR -&gt; M -&gt; MDR -&gt; IR
分析指令: OP(IR) -&gt; CU
执行指令: Ad(IP) -&gt; MAR -&gt; M -&gt; MDR -&gt; ACC
      : (PC)+1 -&gt; PC
</code></pre></li>
<li><p>计算机系统的多层次结构</p>
<p>微程序机器层 - 传统机器语言层 - 操作系统层 - 汇编语言层 - 高级语言层.</p>
<p>“裸机” - 没有配备软件的纯硬件系统，3-5层称为虚拟机</p>
</li>
<li><p>计算机体系结构和计算机组成的区别和联系</p>
</li>
<li></li>
</ul>
<h2 id="二、数据的表示和运算-1"><a href="#二、数据的表示和运算-1" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h2><h3 id="复习提示-6"><a href="#复习提示-6" class="headerlink" title="复习提示"></a>复习提示</h3><blockquote>
<p>纵观近几年真题，不难发现unsigned,  short, int, long, float, double, 等在C语言中的表示，运算，溢出判断，隐式类型转换, 强制类型转换, IEEE 754浮点数的表示, 以及浮点数的运算，都是考验的重点，需要牢固掌握。</p>
</blockquote>
<p><img src="pat\cc0012.png" alt="image-20200415163700023"></p>
<h3 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h3><ul>
<li><p>Base</p>
<ul>
<li>十进制（Decimal）,二进制（Binary）,十六进制（Hexadecimal）,八进制（Octal）</li>
<li>基数，位权，数码</li>
<li>int, long, unsigned, unsigned long, float : 32位，4字节</li>
<li>short, unsigned short: 16位, 2字节</li>
<li>char: 8位，1字节</li>
<li>double: 64位，8字节</li>
</ul>
</li>
<li><p>进制转换</p>
<ul>
<li>二转八或十六，<ul>
<li>一串二进制数分为3位（八进制）或4位（十六进制）</li>
<li>整数，小数点向左；小数，小数点向右</li>
</ul>
</li>
<li>任意转十，数码与权值相乘，乘积叠加</li>
<li>十转任意，基数乘除法<ul>
<li>整数部分采用除基取余法</li>
<li>小数部分采用乘基取整法，ps: 不是每个十进制小数都可以准确地用二进制表示，比如0.3</li>
</ul>
</li>
</ul>
</li>
<li><p>真值，机器数：真值是带符号“+” 和 “-”的数, 机器数是将符号数字化的数，如 0为正，1为负。</p>
</li>
<li><p>BCD码，二进制编码的十进制数（Binary-Coded Decimal, BCD），常采用4位二进制数表示一位十进制的数码。有8421码，余3码，2421码</p>
<ul>
<li>余3码，在8421码的基础上加(0011)</li>
<li>2421码，特点是大于5的4位二进制数中的最高位为1。如: 5 —&gt; 1011</li>
</ul>
</li>
<li><p>字符与字符串</p>
<ul>
<li>字符编码ASCII码，占7位，表示128个字符。</li>
<li>汉字的表示和编码，占两个字节。</li>
</ul>
</li>
<li><p>校验码</p>
<ul>
<li><p>tips</p>
<ul>
<li>码距不小于2，开始具有检错能力，</li>
<li>码距越大，检错，纠错能力就越强，</li>
<li>检错能力永远大于等于纠错能力</li>
</ul>
</li>
<li><p>奇偶校验码，具有局限性，奇偶校验只能发现数据代码中奇数位的出错情况，但不能纠正错误，常用于对存储器数据的检查或传输数据的检查。</p>
<ul>
<li>只能发现数据代码中奇数位的出错情况，不能纠错，常用于对存储器数据的检查或传输数据的检查。</li>
</ul>
</li>
<li><p>海明（汉明）校验码 *</p>
<ul>
<li><p>纠错理论 L - 1 = D + C 且 D &gt;= C</p>
</li>
<li><p>Steps</p>
<ol>
<li><p>确定海明码的位数，$n+k\le2^k-1$,若要检测两位错，则需再增加1位校验位，即$2^{k-1}\ge n+k$</p>
</li>
<li><p>确定校验位的分布，规定校验位 $P_i$在海明位号为$2^{i-1}$的位置上，其余各位为信息位。</p>
</li>
<li><p>分组以形成校验关系，被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。</p>
</li>
<li><p>校验位取值，校验位$P_i$的值为第$i$组(由校验位校验的数据位)所有位求异或</p>
</li>
<li><p>海明码的校验原理</p>
<p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，若全为 0,则说明无错，否则说明出错，且这个数就是错误位的位号，直接将该位取反就达到了纠错的目的。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>循环冗余校验（CRC）码 *</p>
<ul>
<li>生成多项式$G(x)$是接收端和发送端的一个约定，最高幂次为 R, R+K = N（CRC码的位数）</li>
<li>模2除法，加法和减法的结果相同，都是做异或运算，不借位。</li>
<li>Steps<ul>
<li>移位</li>
<li>相除</li>
<li>检错和纠错，将处错位取反即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h3><ul>
<li><p>表示</p>
<ul>
<li><p>无符号数，</p>
</li>
<li><p>有符号数 | 原码，补码，反码，移码 | 区别真值</p>
<p><img src="pat\cc0002.png" alt="image-20200415085303985"></p>
<p>0为正，1为负，设字长为n+1.</p>
<ul>
<li><p>原码，</p>
<ul>
<li>纯小数表示范围$-(1-2^{-n})\le x\le1-2^{-n}$</li>
<li>整数表示范围$-(2^{n}-1)\le x \le 2^{n}-1$</li>
<li>真值零的原码表示有正零和负零两种形式，<strong>0</strong>0000 = <strong>1</strong>0000</li>
</ul>
</li>
<li><p>补码，</p>
<ul>
<li><p>纯小数表示范围$-1\le x\le 1-2^{-n}$，（比原码多表示 $-{1}$）</p>
</li>
<li><p>整数表示范围$-2^n \le x \le 2^n-1$, (比原码多表示$-2^n$)</p>
</li>
<li><p>真值零的补码表示是唯一的，<strong>0</strong>0000</p>
</li>
<li><p>对于正数，补码与原码的表示相同</p>
</li>
<li><p>对于负数， $[x]<em>原 \rarr [x]</em>补 或 [x]<em>补\rarr[x]</em>原$</p>
<p>符号为不变，数值部分按位取反，末位加1</p>
</li>
</ul>
</li>
<li><p>反码</p>
<ul>
<li>纯小数表示范围$-(1-2^{-n})\le x\le1-2^{-n}$</li>
<li>纯整数表示范围$-(2^{n}-1)\le x \le 2^{n}-1$</li>
<li>真值零的反码表示不唯一，0.0000 = 1.1111</li>
</ul>
</li>
<li><p>移码</p>
<ul>
<li>常用来表示浮点数的阶码，它只能表示整数。</li>
<li>真值零的移码表示唯一，100…..0（n 个 0）</li>
<li>$[x]<em>补的符号位取反即得[x]</em>移$</li>
<li>移码全 0 时，对应真值的最小值$-{2^n}$，移码全 1 时，对应真实的最大值 $2^n-1$</li>
<li>移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小</li>
</ul>
</li>
</ul>
</li>
<li><p>定点表示</p>
<p>定点小数($1-2^{-n}$)，定点整数($2^n - 1$)</p>
</li>
<li><p>补码的算术移位</p>
</li>
</ul>
</li>
<li><p>运算</p>
<ol>
<li><p>移位</p>
<ul>
<li><p>算术移位 (有符号数), 移位过程中，符号位保持不变</p>
<p><img src="pat\cc0003.png" alt="image-20200415090704152"></p>
</li>
<li><p>逻辑移位，操作对象是逻辑代码，可视为无符号数</p>
</li>
<li><p>循环移位</p>
<ul>
<li><p>带进位标志位CF的循环移位（大循环）,不带进位标志位的循环移位（小循环）</p>
</li>
<li><p>特点：移出的数位又被移入数据</p>
</li>
<li><p>适合将数据的低字节数据和高字节数据互换</p>
<p><img src="pat\cc0040.png" alt="image-20200421074304970"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原码定点数的加减法运算</p>
</li>
<li><p>补码定点数的加减法运算</p>
<p>计算机系统中普遍采用补码加减运算</p>
</li>
<li><p>符号扩展</p>
<ul>
<li>整数，所有附加位都用 0进行填充</li>
<li>负数-补码，所有附加位用 1(整数) 或 0(小数)进行填充</li>
<li>负数-反码，所有附加位用 1进行填充</li>
</ul>
</li>
<li><p>溢出概念和判别方法</p>
<ul>
<li><p>大于机器所能表示的最大正数为 上溢</p>
</li>
<li><p>小于机器所能表示的最小负数为  下溢</p>
</li>
<li><p>补码溢出判断</p>
<ol>
<li>采用一位符号位<script type="math/tex; mode=display">
V=A_sB_S\overline{S_s}+\overline{A_SB_S}S_s</script></li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>      V=0，表示无溢出；V=1，表示有溢出

   2. 采用双符号位，也称模 4 补码

      $S_{s1}S_{s2}$相同，表示未溢出，不同，表示溢出，此时最高位符号位代表真正的符号

   3. 采用一位符号位根据数据位的进位情况判断溢出

      若符号位的进位$C_s$与最高数位的进位相同，说明没有溢出，否则表示发生溢出
</code></pre><ol>
<li><p>定点数的乘法运算</p>
<p>乘法运算由累加和右移操作实现</p>
<ul>
<li><p>原码一位乘法</p>
<p>符号位与数值位分开求，符号位求异或，数值位求两绝对值的乘积（过程中的移位操作均为逻辑移位），操作中引入双符号位</p>
<p><img src="pat\cc0004.png" alt="image-20200415095730311"></p>
</li>
<li><p>补码一位乘法（Booth算法）</p>
<p>一种有符号数的乘法，采用相加或相减操作计算补码数据的乘积，（移位操作为补码右移），引入双符号位，（共进行 n+1 次累加和 n 次右移）.</p>
<p><img src="pat\cc0005.png" alt="image-20200415103918725"></p>
</li>
<li><p>乘法运算总结</p>
<p><img src="pat\cc0006.png" alt="image-20200415103945094"></p>
</li>
</ul>
</li>
<li><p>定点数的除法运算</p>
<p>除法运算可转换成 “累加-左移”（逻辑左移）</p>
<ul>
<li><p>原码除法，主要采用原码不恢复余数法，也称原码加减交替除法</p>
<p>特点：商符合商值分开进行，商符求异或.</p>
<ol>
<li>先用被除数减去除数，<ol>
<li>当余数为正时，商上 1，余数和商左移一位，再减去除数。</li>
<li>当余数为负时，商上0，余数和商左移一位，再加上除数。</li>
<li>当第 n + 1 步余数为负时，需加上 |Y| 得到 第 n + 1 步正确的余数</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="pat\cc0007.png" alt="image-20200415104618758"></p>
</li>
</ol>
<ul>
<li><p>补码除法，(加减交替法)</p>
<ol>
<li>被除数与除数同号，则被除数减去除数；异号，被除数加上除数</li>
<li>余数与除数同号，则商上 1，余数左移一位减去除数；异号，则商上 0，余数左移一位加上除数</li>
<li>若对商的精度没有特殊要求，则一般采用 “末位恒置 1” 法</li>
<li>Tips<ul>
<li>异号相除是看够不够减，然后上商，够减商0，不够减商1.</li>
</ul>
</li>
</ol>
<p><img src="pat\cc0008.png" alt="image-20200415104730652"></p>
</li>
<li><p>除法运算总结</p>
<p><img src="pat\cc0009.png" alt="image-20200415105236961"></p>
</li>
</ul>
<ul>
<li><p>强制类型转换</p>
<ul>
<li>强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。</li>
</ul>
</li>
<li><p>数据的存储和排列，</p>
<ul>
<li>大端方式和小端方式</li>
<li>边界对齐方式相对边界不对齐方式是一种空间换时间的思想。</li>
</ul>
</li>
</ul>
<h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><ul>
<li><p>表示</p>
<ul>
<li><p>tips</p>
<ul>
<li>将比例因子表示在数据中，让小数点的位置根据需要而浮动，这样在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。</li>
</ul>
</li>
<li><p>表示格式</p>
<p><img src="pat\cc0010.png" alt="image-20200415122624796"></p>
</li>
<li><p>规格化浮点数</p>
<ul>
<li>规定尾数的最高数位必须是一个有效值</li>
<li>左规，算术左移一位、阶码减1</li>
<li>右规，算术右移一位、阶码加1</li>
<li>规格化浮点数的尾数 M 的绝对值应满足条件 $1/r\le |M|\le1$</li>
<li>原码<ul>
<li>正数尾数的表示范围 $1/2\le M\le(1-2^{-n})$</li>
<li>负数尾数的表示范围$-(1-2^{-n})\le M\le-1/2$</li>
</ul>
</li>
<li>补码<ul>
<li>正数尾数的表示范围$1/2\le M\le(1-2^{-n})$</li>
<li>负数尾数的表示范围$-1\le M \le-(1/2+2^{-n})$</li>
</ul>
</li>
<li>基数 r 不同，浮点数的规格化形式也不同</li>
</ul>
</li>
<li><p>IEEE754标准</p>
<p>IEEE754标准的浮点数（除临时浮点数外），是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。</p>
<p><img src="pat\cc0011.png" alt="image-20200415154108158"></p>
</li>
<li><p>定点, 浮点表示的区别</p>
<p>浮点表示相比较而言，表示范围远远扩大、精度有所下降、运算较复杂、（非规格化）不一定会溢出</p>
<ul>
<li>精度，是指一个数所含有效数值位的位数</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点数的加减运算</p>
<ul>
<li><p>特点：阶码运算和尾数运算分开进行，一律采用补码.</p>
</li>
<li><p>分为以下几步：对阶 | 尾数求和 | 规格化 | </p>
<ul>
<li>舍入，0 舍 1 入法；恒置 1 法</li>
<li>| 溢出判断 | 强制类型转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算术逻辑单元（ALU）"><a href="#算术逻辑单元（ALU）" class="headerlink" title="算术逻辑单元（ALU）"></a>算术逻辑单元（ALU）</h3><ul>
<li><p>加法器</p>
<p>一位全加器 | </p>
<ul>
<li>串行加法器，<ul>
<li>加法分 n 次进行</li>
<li>器件少，成本低；运算速度慢，多用于某些低俗的专用运算器</li>
</ul>
</li>
<li>并行加法器<ul>
<li>位数与机器的字长相同</li>
<li>并行加法器的最长运算时间主要由进位信号的<strong>产生</strong>和<strong>传递</strong>时间决定</li>
<li>串行进位，又称行波进位，位数越多延迟时间就越长；最长运算时间取决于进位信号的传递时间；</li>
<li>并行进位，又称先行进位、同时进位；</li>
<li>分组并行进位方式，常用，组内并行，组间串行</li>
<li>并行快速进位方式<ul>
<li>单级先行进位方式，又称组内并行，组间串行进位方式</li>
<li>多级先行进位方式，又称组内并行，组间并行进位方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算术逻辑单元的功能和结构</p>
<ul>
<li>74181</li>
</ul>
</li>
</ul>
<h2 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a>三、存储系统</h2><p><img src="pat\cc0039.png" alt="image-20200417171803471"></p>
<h3 id="1-存储器的层次结构"><a href="#1-存储器的层次结构" class="headerlink" title="1. 存储器的层次结构"></a>1. 存储器的层次结构</h3><ul>
<li><p>分类</p>
<ul>
<li><p>作用</p>
<p>主存储器（主存，内存）、辅助存储器（外存）、高速缓冲存储器（Cache）</p>
</li>
<li><p>介质 </p>
<p>磁表面存储器（磁盘，磁带）、磁心存储器半导体存储器（MOS行存储器，双极行存储器）和光存储器（光盘）</p>
</li>
<li><p>存取方式 </p>
<p>随机存储器（RAM）、只读存储器（ROM）、串行访问存储器</p>
</li>
<li><p>可保存性</p>
<p>易失存储器，非易失存储器</p>
</li>
</ul>
</li>
<li><p>性能指标</p>
<p>存储容量 | 单位成本 | </p>
<ul>
<li><p>存储速度</p>
<p>数据传输率 = 数据的宽度 / 存储周期</p>
<p>存取时间$T_a$，存取周期$T_m$，主存带宽$B_m$(又称数据传输率)</p>
<p><img src="pat\cc0017.png" alt="image-20200416091740042"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-存储器的层次化结构"><a href="#2-存储器的层次化结构" class="headerlink" title="2. 存储器的层次化结构"></a>2. 存储器的层次化结构</h3><p>（磁带，光盘）—&gt; 磁盘—&gt; 主存—&gt; Cache—&gt; 寄存器 </p>
<p><img src="pat\cc0018.png" alt="image-20200416091808654"></p>
<h3 id="3-半导体随机存储器"><a href="#3-半导体随机存储器" class="headerlink" title="3. 半导体随机存储器"></a>3. 半导体随机存储器</h3><ul>
<li><p>半导体存储芯片</p>
<ul>
<li><p>基本结构：存储矩阵，译码驱动，读写电路，读/写控制线，片选线，地址线，数据线</p>
<p><img src="pat\cc0013.png" alt="image-20200416090923861"></p>
</li>
<li><p>74138译码器</p>
</li>
<li><p>tips</p>
<ul>
<li>地址线和数据线共同反应存储芯片容量大小，如地址线10根，数据线8根，则芯片容量=$2^{10}*8$</li>
</ul>
</li>
</ul>
</li>
<li><p>SRAM和DRAM</p>
<ul>
<li><p>SRAM工作原理</p>
</li>
<li><p>DRAM工作原理</p>
<p>DRAM电容上的电荷只能维持1~2 ms</p>
<ul>
<li><p>集中刷新，</p>
<p>读写操作时，不受刷新影响，因此系统的存取速度较高；缺点是在集中刷新期间（死区）不能访问存储器。</p>
</li>
<li><p>分散刷新</p>
<p>优点是没有死区；缺点是加长了系统的存取周期，降低了整机的速度</p>
</li>
<li><p>异步刷新</p>
<p>前两种的结合。避免是CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率</p>
</li>
</ul>
</li>
<li><p>RAM的读 写周期</p>
<ul>
<li><p>写周期不明确</p>
<p><img src="pat\cc0014.png" alt="image-20200416091007324"></p>
<p><img src="pat\cc0015.png" alt="image-20200416091027604"></p>
</li>
</ul>
</li>
<li><p>SRAM 和 DRAM 的比较.</p>
<p><img src="pat\cc0016.png" alt="image-20200416091047962"></p>
</li>
<li><p>tips</p>
<ul>
<li>地址码相同的多个存储元构成一个存储单元</li>
</ul>
</li>
</ul>
</li>
<li><p>只读存储器</p>
<ul>
<li><p>ROM的特点，</p>
<ul>
<li>结构简单，所以位密度比可读写存储器的高</li>
<li>具有非易失性，可靠性高</li>
</ul>
</li>
<li><p>类型</p>
<p>掩膜式只读存储器MROM，一次可编程只读存储器PROM，可擦除可编程只读存储器EPROM(编程次数有限)，闪速存储器Flash Memory，固态硬盘Solid State Drivers.</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-主存储器与CPU的连接"><a href="#4-主存储器与CPU的连接" class="headerlink" title="4. 主存储器与CPU的连接"></a>4. 主存储器与CPU的连接</h3><ul>
<li><p>连接原理</p>
<p>数据总线，地址总线，控制总线</p>
<p><img src="pat\cc0019.png" alt="image-20200416092151976"></p>
</li>
<li><p>主存容量的扩展</p>
<ul>
<li><p>位扩展法</p>
<ul>
<li><p>连接方式，是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据短分别引出。</p>
</li>
<li><p>仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以片选信号$\overline{CS}$要连接到所有芯片</p>
</li>
<li><img src="pat\cc0020.png" alt="image-20200416093543997"></li>
</ul>
</li>
<li><p>字扩展法</p>
<ul>
<li>字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分给芯片的地址范围。</li>
<li>仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部门芯片，所以通过片选信号$\overline{CS}$或采用译码器设计连接到相应的芯片</li>
<li><img src="pat\cc0021.png" alt="image-20200416093600555"></li>
</ul>
</li>
<li><p>字位同时扩展法</p>
<ul>
<li>采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号$\overline{CS}$或采用译码器设计连接到相应的芯片。</li>
<li><img src="pat\cc0022.png" alt="image-20200416093630896"></li>
</ul>
</li>
</ul>
</li>
<li><p>存储芯片的地址分配和片选</p>
<p>CPU对存储单元进行访问，首先要选择存储芯片（片选），然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取（字选）。片内的字选通常是由CPU送出的 N 条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量$2^N$决定）</p>
<ul>
<li><p>线选法</p>
<p>优：不需要地址译码器，线路简单；缺：地址空间不连续，选片的地址线必须分时为低电平（否则不能工作），不能充分利用系统的存储器空间，造成地址资源的浪费</p>
</li>
<li><p>译码片选法</p>
<p>用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。</p>
</li>
</ul>
</li>
<li><p>存储器与CPU的连接</p>
<ul>
<li><p>合理选择存储芯片</p>
</li>
<li><p>地址线的连接</p>
<ul>
<li>CPU的地址线数往往比存储芯片的地址线数要多</li>
<li>通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选），这部分的译码是由芯片的片内逻辑完成的。</li>
<li>而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成</li>
</ul>
</li>
<li><p>数据线的连接</p>
<p>CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连；在不相等时必须对存储芯片扩位，使两者相等</p>
</li>
<li><p>读/写命令线的连接</p>
</li>
<li><p>片选线的连接</p>
<p>片选线的连接是CPU与存储芯片连接的关键。存储器有许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端$\overline{CS}$是否能接收到来自CPU的片选有效信号。</p>
<p>片选信号与CPU的访存控制信号$\overline{MREQ}$(低电平有效)有关</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-双端口RAM和多模块存储器"><a href="#5-双端口RAM和多模块存储器" class="headerlink" title="5. 双端口RAM和多模块存储器"></a>5. 双端口RAM和多模块存储器</h3><p>为了提高CPU访存速度，可采用双端口存储器、多模块存储器等技术，它们同属并行技术，前者为空间并行，后者为时间并行。</p>
<ul>
<li><p>双端口RAM</p>
<p><img src="pat\cc0023.png" alt="image-20200416110501870"></p>
</li>
<li><p>多模块存储器</p>
<ul>
<li><p>单体多字存储器</p>
<ul>
<li>优：增大了存储器的宽度，提高了单体存储器的工作速度</li>
<li>缺：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显</li>
<li><img src="pat\cc0024.png" alt="image-20200416111348145"></li>
</ul>
</li>
<li><p>多体并行存储器</p>
<ul>
<li><p>高位交叉编址（顺序方式），高位地址表示体号，低位地址为体内地址</p>
</li>
<li><p>低位交叉编址（交叉方式），低位地址为体号，高位地址为体内地址</p>
</li>
<li><p><img src="pat\cc0025.png" alt="image-20200416111429989"></p>
<p><img src="pat\cc0026.png" alt="image-20200416111529976"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-高速缓冲存储器"><a href="#6-高速缓冲存储器" class="headerlink" title="6. 高速缓冲存储器"></a>6. 高速缓冲存储器</h3><p>因为单纯依靠并行主存系统提高主存系统的频宽是有限的，所以 <strong>Cache</strong> 闪亮登场.</p>
<ul>
<li><p>程序访问的局部性原理，包括时间局部性和空间局部性</p>
<p>高速缓冲技术就是利用程序访问的局部性原理。</p>
</li>
<li><p>Cache的基本工作原理，cache常由SRAM构成</p>
<p><img src="pat\cc0027.png" alt="image-20200416112311148"></p>
<ul>
<li>CPU与Cache之间的数据交换以字位单位，而Cache与主存之间的数据交换以Cache块进行。</li>
<li>Cache写策略处理，全写法和写回法</li>
<li>Cache的命中率，$H=N_c / (N_c+N_m)$</li>
<li>Cache-主存系统的平均访问时间 $T_a=Ht_c + (1-H)t_m$</li>
</ul>
</li>
<li><p>Cache和主存的映射方式</p>
<p>在Cache中，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的程序按照某种规则装入Cache。</p>
<p><strong>地址映射</strong>不同于<strong>地址变换</strong>，地址变换是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。</p>
<ul>
<li><p>直接映射，实现简单，但不够灵活，块冲突概率最高，空间利用率最低</p>
<p><img src="pat\cc0028.png" alt="image-20200416131530914"></p>
</li>
<li><p>全相联映射，比较灵活，Cache块的冲突概率低，空间利用率高，命中率也高；缺点：地址变换速度慢，实现成本高，通常采用昂贵的按内容寻址的相连存储器进行地址映射。</p>
<p><img src="pat\cc0029.png" alt="image-20200416132117635"></p>
</li>
<li><p>组相联映射</p>
<p>组间采取直接映射，组内采取全相连映射</p>
<p><img src="pat\cc0030.png" alt="image-20200416132300835"></p>
</li>
</ul>
</li>
<li><p>Cache中主存块的替换算法</p>
<ul>
<li><p>随机算法（RAND）</p>
<p>实现比较简单，但未依据程序访问的局部性原理，故可能命中率较低.</p>
</li>
<li><p>先进先出算法（FIFO）</p>
<p>容易实现，但也未依据程序访问的局部性原理，可能会把常用的程序块作为最早进入Cache的块替换掉。</p>
</li>
<li><p>近期最少使用算法（LRU）</p>
<p>依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比FIFO的高，是堆栈类算法。</p>
<p>LRU对每行设置一个计数器，Cache每命中一次，命中行计数清 0，其它行计数器均加 1。计数值最大的行换出。</p>
</li>
<li><p>最不经常使用算法（LFU）</p>
<p>将一段时间内被访问次数最少的存储行换出，每行也设置一个计数器，新行初始为0，每访问一次，被访问行计数器加 1，计数值最小的行换出</p>
</li>
</ul>
</li>
<li><p>Cache写策略，对于Cache写命中 （write hit）</p>
<ul>
<li><p>全写法（写直通法，write-through）</p>
<p>实现简单，随时保持主存数据的正确性。缺点：增加了访存次数，降低了Cache的效率。</p>
<p>写缓冲（Write Buffer）:减少全写法直接写入主存的时间消耗，是一个FIFO队列</p>
<p><img src="pat\cc0031.png" alt="image-20200416134615194"></p>
</li>
<li><p>写回法（write-back）</p>
<p>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。</p>
<p>减少了访存次数，但存在不一致的隐患，</p>
<p>每个Cache行必须设置一个标志位（脏位），以反映此块是否被CPU修改过。</p>
</li>
</ul>
<p>写不命中</p>
<ul>
<li><p>写分配法（write-allocate）</p>
<p>加载主存中的块到Cache中，然后更新这个Cache块，它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块</p>
</li>
<li><p>非写分配法（not-write-allocate）</p>
<p>只写入主存，不进行调块</p>
</li>
<li><p>多级Cache</p>
<p>通常为 3 级，离CPU越远，访问速度越慢，容量越大。指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与写回法合用。</p>
<p><img src="pat\cc0032.png" alt="image-20200416135521197"></p>
</li>
</ul>
</li>
</ul>
<h3 id="7-虚拟存储器"><a href="#7-虚拟存储器" class="headerlink" title="7. 虚拟存储器"></a>7. 虚拟存储器</h3><p>虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比。</p>
<ul>
<li><p>基本概念</p>
<ul>
<li><p>用于编程允许设计的地址称为 虚地址或逻辑地址，虚地址对应的存储空间或程序空间；实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也成实地址空间。虚地址要比实地址大很多。程序进行虚地址到实地址转换的过程称为程序的再定位。</p>
<p><img src="pat\cc0033.png" alt="image-20200416140637976"></p>
<p><img src="pat\cc0034.png" alt="image-20200416140953719"></p>
<p><img src="pat\cc0035.png" alt="image-20200417153426797"></p>
</li>
</ul>
</li>
<li><p>页式虚拟存储器</p>
<ul>
<li><p>虚地址分为两个字段：虚页号 和 页内地址</p>
</li>
<li><p>页表，虚页号和实页号的对照表；页表项：虚页号，实页号，装入位</p>
</li>
<li><p>优： 页面长度固定，页表简单，调入方便。缺：处理，保护和共享都不及段式虚拟存储器方便。</p>
<p><img src="pat\cc0036.png" alt="image-20200417161620586"></p>
</li>
</ul>
</li>
<li><p>段式虚拟存储器</p>
<ul>
<li><p>虚拟地址分为两部分：段号和段内地址</p>
</li>
<li><p>段表，是程序逻辑段和在主存中存放位置的对照表；段表行：段号，装入位，段起点和段长</p>
</li>
<li><p>优：易于编译，管理，修改和保护，也便于多道程序的共享；缺：容易在段间留下碎片，造成浪费。</p>
<p><img src="pat\cc0037.png" alt="image-20200417165214875"></p>
</li>
</ul>
</li>
<li><p>段页式虚拟存储器</p>
<ul>
<li>徐地址分为段号，段内页号，页内地址三部分。</li>
</ul>
</li>
<li><p>块表（TLB）</p>
<ul>
<li>存储在高速缓冲器的页表项，相应地存放在主存中的页表为慢表（Page）,是块表的超集。</li>
</ul>
</li>
<li><p>虚拟存储器与Cache的比较</p>
<p><img src="pat\cc0038.png" alt="image-20200417171131081"></p>
</li>
</ul>
<h3 id="8-tips"><a href="#8-tips" class="headerlink" title="8. tips"></a>8. tips</h3><ul>
<li><p>相联存储器既可以按地址寻址，又可以按内容寻址，又称按内容寻址的存储器。</p>
</li>
<li><p>软件和硬件的逻辑上是等效的，不是等价的</p>
</li>
<li><p>什么是存储程序原理？按此原理，计算机应具有哪几大功能？</p>
<blockquote>
<ul>
<li>存储程序是指将指令以代码的形式事先输入计算机主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li>
<li>计算机按照此原理应该具有 5 大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="四、指令系统-1"><a href="#四、指令系统-1" class="headerlink" title="四、指令系统"></a>四、指令系统</h2><p><img src="pat\cc0045.png" alt="image-20200421101751126"></p>
<h3 id="1-指令格式"><a href="#1-指令格式" class="headerlink" title="1. 指令格式"></a>1. 指令格式</h3><p>指令，又称机器指令，是计算机运行的最小功能单位。指令系统是计算机的主要属性，位于硬件和软件的交界层面上。</p>
<ul>
<li><p>基本格式</p>
<ul>
<li><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码，包括 操作码字段 和 地址码字段。</p>
</li>
<li><p>指令长度：单字长指令，半字长指令，双字长指令</p>
</li>
<li><p>定长指令字结构和变长指令字结构</p>
</li>
<li><p>根据指令中操作数地址码的 数目 的不同，可分为</p>
<ul>
<li><p>零地址指令</p>
<ul>
<li>不需要操作数的指令，如空操作指令，停机指令，关中断指令等</li>
<li>零地址的运算类指令仅用在堆栈计算机中</li>
</ul>
</li>
<li><p>一地址指令</p>
<ul>
<li><p>只有目的操作数的但操作数指令</p>
<p>$OP(A_1)\rarr A_1$ ,如加1，减1，求反，求补</p>
</li>
<li><p>隐含约定目的地址的双操作数指令，如ACC(累加器)</p>
<p>$(ACC)OP(A_1)\rarr ACC$</p>
</li>
</ul>
</li>
<li><p>二地址指令</p>
<p>$(A_1)OP(A_2)\rarr A_1$</p>
</li>
<li><p>三地址指令</p>
<p>$(A_1)OP(A_2)\rarr A_3$</p>
</li>
<li><p>四地址指令</p>
<p>$(A_1)OP(A_2)\rarr A_3,\ A_4 = 下一条将要执行指令的地址$，</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定长操作码指令格式</p>
<p>一般 n 位操作码字段的指令系统最大能够表示 $2^n$ 条指令.</p>
</li>
<li><p>扩展操作码指令格式</p>
<p><img src="pat\cc0041.png" alt="image-20200421083850930"></p>
<ul>
<li><p>设计操作码指令格式时，需注意：</p>
<ul>
<li><p>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同</p>
</li>
<li><p>各指令的操作码一定不能重复</p>
<p>一般地，使用频率较高的指令分配较短的操作码，使用频率低的指令分配较长的操作码，以减少指令译码和分析的时间。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-指令寻址方式"><a href="#2-指令寻址方式" class="headerlink" title="2. 指令寻址方式"></a>2. 指令寻址方式</h3><p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。形式地址（A）+ 寻址方式 = 有效地址（EA）.</p>
<ul>
<li><p>指令寻址</p>
<ul>
<li>顺序寻址方式，（PC）+ 1（1个指令字长）</li>
<li>跳跃寻址方式，通过转移类指令实现。</li>
</ul>
</li>
<li><p>数据寻址</p>
<p>数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。</p>
<p><img src="pat\cc0042.png" alt="image-20200421085735794"></p>
</li>
<li><p>常见的数据寻址方式</p>
<p><img src="pat\cc0043.png" alt="image-20200421101118602"></p>
<ol>
<li><p>隐含寻址</p>
<p>累加器（ACC）对单地址指令格式来说是隐含地址。</p>
<p>优：利于缩短指令字长；缺：需增加存储操作数或隐含地址的硬件</p>
</li>
<li><p>立即（数）寻址</p>
<p>优：指令在执行阶段不访问主存，指令执行时间最短；缺：A的位数限制了立即数的范围。</p>
</li>
<li><p>直接寻址,<strong>EA = A</strong></p>
<p>指令字中的形式地址 A 是操作数的真实地址 EA.</p>
<p>优：简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址。</p>
<p>缺：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改</p>
</li>
<li><p>间接寻址，<strong>EA = (A)</strong></p>
<p>即操作数地址的地址，一次间接寻址或多次间接寻址.</p>
<p>优：可扩大寻址范围，便于编制程序；</p>
<p>缺：指令在执行阶段要多次访存，优于访问速度过慢，所以不常用，一般问道扩大寻址范围时，通常指的是寄存器间接寻址。</p>
</li>
<li><p>寄存器寻址，<strong>EA =</strong> $R_i$</p>
<p>指在指令字中直接给出操作数所在的寄存器编号,其操作数在有 $R_i$所指的寄存器内。</p>
<p>优：指令在执行阶段不访问主存，只访问寄存器，因寄存器数量少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算</p>
<p>缺：寄存器价格昂贵，计算机中的寄存器个数有限。</p>
</li>
<li><p>寄存器间接寻址，<strong>EA =</strong> $(R_i)$</p>
<p>指在寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址。</p>
<p>特点：比一般简介寻址速度更快，但指令的执行阶段需要访问主存。</p>
</li>
<li><p>相对寻址，<strong>EA = （PC）+ A</strong></p>
<p>把程序计数器（PC）的内容加上指令格式中的形式地址 A 而形成操作数的有效地址。其中 A 是相对于当前指令地址的位移量，可正可负，补码表示。</p>
<p>优：操作数地址不固定，随 PC 值得变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动，相对寻址广泛应用于转移指令。</p>
</li>
<li><p>基址寻址, <strong>EA = (BR) + A</strong></p>
<p>CPU中基址寄存器（BR）的内容加上指令格式中的形式地址 A 而形成操作数的有效地址. 其中基址寄存器即可采用专用寄存器，又可采用通用寄存器。基址寄存器面向操作系统，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。</p>
<p>优：可扩大寻址范围，用户不必考虑自己的程序存于主存的哪个空间区域，故有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址 A）的位数较短。</p>
</li>
<li><p>变址寻址，EA = (IX) + A</p>
<p>指有效地址 EA 等于指令字中的形式地址 A 与 变址寄存器 IX 的内容之和。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址 A 不变（作为基地址）。</p>
<p>变址寻址与基址寻址的有效地址形成过程极为相似，但本质上讲，两者有较大区别：</p>
<ul>
<li>基址寻址面向系统，主要用于为多道程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的。</li>
<li>变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的 A 是不可变的。</li>
</ul>
</li>
<li><p>堆栈寻址</p>
<p>该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）.</p>
<ul>
<li>寄存器堆栈又称硬堆栈，成本较高，不适合做大容量堆栈，</li>
<li>从主存中划出来一段区域来做堆栈是最合算且最常用的方法，称为软堆栈。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-CISC和RISC的基本概念"><a href="#3-CISC和RISC的基本概念" class="headerlink" title="3. CISC和RISC的基本概念"></a>3. CISC和RISC的基本概念</h3><ul>
<li><p>复杂指令系统计算机(CISC)</p>
</li>
<li><p>精简指令系统计算机(RISC)</p>
</li>
<li><p>两者的比较</p>
<p><img src="pat\cc0044.png" alt="image-20200421101601845"></p>
</li>
</ul>
<h2 id="五、中央处理器"><a href="#五、中央处理器" class="headerlink" title="五、中央处理器"></a>五、中央处理器</h2><p><img src="pat\cc0060.png" alt="image-20200423091149075"></p>
<h3 id="1-CPU的功能和基本结构"><a href="#1-CPU的功能和基本结构" class="headerlink" title="1. CPU的功能和基本结构"></a>1. CPU的功能和基本结构</h3><ul>
<li><p>功能</p>
<ul>
<li>控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令。</li>
<li>运算器的功能是对数据进行加工。</li>
<li>CPU的功能包括：1. 指令控制；2.操作控制；3.时间控制；4.数据加工；5.中断处理</li>
</ul>
</li>
<li><p>基本结构</p>
<ul>
<li><p>运算器</p>
<ul>
<li>1.算术逻辑单元（ALU），进行逻辑/算术运算</li>
<li>2.暂存寄存器 ，暂存从主存读来的数据，对应用程序员透明</li>
<li><p>3.累加寄存器（ACC），通用寄存器，暂存ALU运算的结果信息，可以作为加法运算的一个输入端</p>
</li>
<li><p>4.通用寄存器组 </p>
<p>如AX, BX, CX, DX, SP等，用于存放操作数（源操作数，目的操作数及中间结果）和各种地址信息。SP是堆栈指针，用于指示栈顶的地址。</p>
</li>
<li><p>5.程序状态字寄存器（PSW）</p>
<p>溢出标志（OF）,符号标志（SF），零标志（CF），进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。</p>
</li>
<li><p>6.移位器 ，对操作数和运算结果进行移位运算</p>
</li>
<li><p>7.计数器（CT），控制乘除运算的操作步数。</p>
</li>
</ul>
</li>
<li><p>控制器</p>
<p>基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。控制器分 硬布线控制器和微程序控制器两种类型。</p>
<ol>
<li>程序计数器（PC）</li>
<li>指令寄存器（IR），保存当前正在执行的指令</li>
<li>指令译码器，仅对操作码字段进行译码，向控制器提供特定的操作信号。</li>
<li>存储器地址寄存器，用于存放所要访问的主存单元的地址</li>
<li>存储器数据寄存器，用于存放向主存写入的信息或从主存中读出的信息</li>
<li>时序系统，用于产生各种时序信号，它们都由统一视同（CLOCK）分频得到</li>
<li>微操作信号发生器，根据IR的内容，PSW的内容及 时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</li>
<li>控制器的工作原理：根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果.</li>
</ol>
<p>寄存器</p>
<ul>
<li>用户可见，通用寄存器组，程序状态字寄存器</li>
<li>用户不可见，存储器地址寄存器，存储器数据寄存器，指令寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-指令执行过程"><a href="#2-指令执行过程" class="headerlink" title="2. 指令执行过程"></a>2. 指令执行过程</h3><ul>
<li><p>指令周期</p>
<ul>
<li>CPU从主存中每取出并执行一条指令所需的全部时间称为指令周期。</li>
<li>取指周期：取指令；间址周期：取有效地址；执行周期：取操作数；中断周期：保存程序断点。</li>
<li>4个标志触发器FE、IND、EX 和 INT，分别对应上述四个周期，1 状态表示有效</li>
<li>中断周期中的进栈操作是减 1，因为计算机的堆栈中都是向低地址增加。</li>
</ul>
</li>
<li><p>指令周期的数据流</p>
<p>数据流是根据指令要求依次访问的数据序列。</p>
<ul>
<li><p>取指周期</p>
<p><img src="pat\cc0046.png" alt="image-20200422151908182"></p>
</li>
<li><p>间址周期</p>
<p><img src="pat\cc0047.png" alt="image-20200422152153013"></p>
</li>
<li><p>执行周期</p>
<p>不同指令的执行周期操作不同，因此没有同意的数据流向</p>
</li>
<li><p>中断周期</p>
<p><img src="pat\cc0048.png" alt="image-20200422153333241"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>指令执行方案</p>
<ul>
<li><p>单指令周期</p>
<p>对所有指令都选用相同的执行时间来完成，此时每条指令 都在固定的时钟周期内完成。会降低整个系统的运行速度。</p>
</li>
<li><p>多指令周期</p>
<p>选用不同个数的时钟周期来完成不同的指令的执行过程</p>
</li>
<li><p>流水线方案</p>
<p>指令之间并行执行。追求目标是力争在每个时钟脉冲周期完成一条指令的执行过程（理想状态）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-数据通路的功能和基本结构"><a href="#3-数据通路的功能和基本结构" class="headerlink" title="3. 数据通路的功能和基本结构"></a>3. 数据通路的功能和基本结构</h3><ul>
<li><p>功能</p>
<p>数据在功能部件之间传送的路径称为数据通路。功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。建立数据通路的任务是由 “操作控制部件” 来完成的。</p>
</li>
<li><p>数据通路的基本结构</p>
<ul>
<li><p>CPU内部单总线方式，多冲突，性能低</p>
</li>
<li><p>CPU内部三总线方式，效率较高</p>
</li>
<li><p>专用数据通路方式，性能较高，但硬件量大。</p>
</li>
<li><p>Attention</p>
<p>内部总线是指同一部件，如CPU内部链接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU, 内存， 通道和各类 I/O 接口间互相连接的总线。</p>
</li>
</ul>
</li>
<li><p>Others</p>
<ul>
<li><p>寄存器之间的数据传送</p>
</li>
<li><p>主存与CPU之间的数据传送</p>
</li>
<li><p>执行算术或逻辑运算</p>
<p><img src="pat\cc0049.png" alt="image-20200422160330050"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-控制器的功能和工作原理"><a href="#4-控制器的功能和工作原理" class="headerlink" title="4. 控制器的功能和工作原理"></a>4. 控制器的功能和工作原理</h3><ul>
<li><p>结构和功能</p>
<p><img src="pat\cc0050.png" alt="image-20200422160703994"></p>
<ul>
<li>根据控制器产生微操作控制信号的方式的不同，控制器可分为以下两种</li>
</ul>
</li>
<li><p>硬布线控制器</p>
<ul>
<li><p>硬布线控制单元图</p>
<p><img src="pat\cc0051.png" alt="image-20200422161311435"></p>
</li>
<li><p>硬布线控制器的时序系统及微操作</p>
<ul>
<li><p>时钟周期</p>
</li>
<li><p>机器周期</p>
</li>
<li><p>指令周期</p>
</li>
<li><p>微操作命令分析</p>
<p><img src="pat\cc0052.png" alt="image-20200422161800652"></p>
</li>
</ul>
</li>
<li><p>CPU的控制方式</p>
<ul>
<li>同步控制方式，优点：控制电路简单，缺点：运行速度慢</li>
<li>异步控制方式，优点：运行速度快，缺点：控制电路复杂</li>
<li>联合控制方式，对各种不同的指令的微操作实行大部分采用同步控制，小部分采用异步控制的办法。</li>
</ul>
</li>
<li><p>硬布线控制单元设计步骤，复杂，详见书本</p>
<ul>
<li>列出微操作命令的操作时间表</li>
<li>进行微操作信号综合</li>
<li>画出微操作命令的逻辑图</li>
</ul>
</li>
</ul>
</li>
<li><p>微程序控制器</p>
<p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。</p>
<ul>
<li><p>基本概念</p>
<ul>
<li>微命令与微操作<ul>
<li>微操作是计算机中最基本的、不可再分解的操作。微命令是构成控制序列的最小单位。微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。</li>
<li>微命令有相容性和互斥性之分。</li>
</ul>
</li>
<li>微指令与微周期<ul>
<li>微指令是若干微命令的集合；存放微指令的控制存储器的单元地址称为微地址。一条微指令包含两大部分：1. 操作控制字段，又称微操作码字段；2. 顺序控制字段，又称微地址码字段。</li>
<li>微周期常指从控制器中读取一条微指令并执行相应的微操作所需的时间。</li>
</ul>
</li>
<li>主存储器与控制存储器<ul>
<li>主存储器用于存放程序和数据，在CPU外部，用 RAM 实现</li>
<li>控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。</li>
</ul>
</li>
<li>程序与微程序<ul>
<li>程序，是指令的有序集合，用于完成特定的功能</li>
<li>微程序，是微指令的有序集合，一条指令的功能由一段微程序来实现。实际上是机器指令的实时解释器。对用户透明。</li>
</ul>
</li>
<li>区分一下寄存器<ul>
<li>地址寄存器（MAR）</li>
<li>微地址寄存器（CMAR）</li>
<li>指令寄存器（IR）</li>
<li>微指令寄存器（CMDR 或 $\mu$IR）</li>
</ul>
</li>
</ul>
</li>
<li><p>组成和工作过程</p>
<ul>
<li><p>基本组成</p>
<p><img src="pat\cc0053.png" alt="image-20200422164610845"></p>
<ul>
<li>控制存储器，存放各指令对应的微程序</li>
<li>微指令寄存器，</li>
<li>微地址形成部件</li>
<li>微地址寄存器</li>
</ul>
</li>
<li><p>工作过程，复杂，见课本</p>
</li>
</ul>
</li>
<li><p>微指令的编码方式</p>
<p>又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。</p>
<ul>
<li><p>直接编码（直接控制）方式</p>
<p>优点是简单、直观，执行速度快，操作并行性好；缺点是微指令字长过长，n 个微指令就要求微指令的操作字段有 n 位，造成控制存储器容量极大。</p>
<p><img src="pat\cc0054.png" alt="image-20200422165313027"></p>
</li>
<li><p>字段直接编码方式</p>
<ul>
<li>可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。</li>
<li>微命令字段分段的原则：见书。</li>
</ul>
</li>
<li><p>字段间接编码方式</p>
<p>又称隐式编码，可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。</p>
</li>
</ul>
</li>
<li><p>微指令的地址形成方式</p>
<ul>
<li>直接由微指令的下地址字段指出，又称断定方式</li>
<li>根据机器指令的操作码形成</li>
</ul>
</li>
<li><p>微指令的格式</p>
<ul>
<li><p>水平型微指令</p>
<p>优点是微程序短，执行速度快；缺点是微指令长，编写微程序较麻烦</p>
</li>
<li><p>垂直型微指令</p>
<p>优点是微指令短，简单，规整，便于编写微程序；缺点是微程序长，执行速度慢，工作效率低。</p>
</li>
<li><p>混合型微指令</p>
<p>微指令较短，仍便于编写；微程序也不长，执行速度加快</p>
</li>
<li><p>水平型微指令和垂直型微指令</p>
<p><img src="pat\cc0055.png" alt="image-20200422170337426"></p>
</li>
</ul>
</li>
<li><p>微程序控制单元的设计步骤</p>
<ol>
<li>写出对应机器指令的微操作命令及节拍安排</li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ol>
</li>
<li><p>动态微程序设计和毫微程序设计</p>
<ol>
<li>动态微程序设计</li>
<li>毫微程序设计</li>
</ol>
</li>
<li><p>硬布线和微程序控制器的特点</p>
<p><img src="pat\cc0056.png" alt="image-20200422170531599"></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-指令流水线"><a href="#5-指令流水线" class="headerlink" title="5. 指令流水线"></a>5. 指令流水线</h3><ul>
<li><p>基本概念</p>
<p>计算机的流水线把一个重复的过程分解为若干子过程，每个子过程与其他子过程并行执行。是一种普遍使用的并行处理技术。</p>
<ul>
<li><p>指令流水的定义</p>
<p>多条指令在处理器中执行时：</p>
<ul>
<li><p>顺序执行方式，T = 3nt</p>
<p>传统冯.诺依曼机采用顺序执行方式，又称串行执行方式。优点是控制简单，硬件代价小；缺点是执行指令的速度较慢。</p>
</li>
<li><p>一次重叠执行方式，T = (1+2n)t</p>
<p>优点：程序的执行时间缩短了 1/3, 各功能部件的利用率明显提高，但硬件上有较大开销，控制过程也较复杂。</p>
</li>
<li><p>二次重叠执行，（2+n）t</p>
<p>时间缩短 2/3，这是一种理想的指令执行方式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  ![image-20200422172613136](pat\cc0057.png)
</code></pre><ul>
<li><p>流水线的表示方法，时空图</p>
<p><img src="pat\cc0058.png" alt="image-20200422173227879"></p>
</li>
<li><p>流水线方式的特点，见书。</p>
<p><img src="pat\cc0059.png" alt="image-20200422173527125"></p>
</li>
</ul>
<ul>
<li><p>流水线的分类</p>
<ul>
<li>部件功能级，处理机级和处理机间级流水线</li>
<li>单功能流水线和多功能流水线</li>
<li>动态流水线和静态流水线</li>
<li>线性流水线和非线性流水线</li>
</ul>
</li>
<li><p>影响流水线的因素</p>
<ul>
<li>结构相关（资源冲突）</li>
<li>数据相关（数据冲突）</li>
<li>控制相关（控制冲突）</li>
</ul>
</li>
<li><p>流水线的性能指标</p>
<ul>
<li>流水线的吞吐率</li>
<li>流水线的加速比</li>
<li>流水线的效率</li>
</ul>
</li>
<li><p>超标量流水线的基本概念</p>
<ul>
<li>超标量流水线技术</li>
<li>超流水线技术</li>
<li>超长指令字</li>
</ul>
</li>
</ul>
<h2 id="六、总线-1"><a href="#六、总线-1" class="headerlink" title="六、总线"></a>六、总线</h2><p><img src="pat\cc0062.png" alt="image-20200423171535237"></p>
<h3 id="1-总线概述"><a href="#1-总线概述" class="headerlink" title="1. 总线概述"></a>1. 总线概述</h3><p>为了更好地解决 I/O 设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接，为了进一步简化设计，又提出了各类总线标准。</p>
<ul>
<li><p>基本概念</p>
<ul>
<li><p>定义</p>
<p>总线是一组能为多个部件<strong>分时</strong>、<strong>共享</strong>的公共信息传送线路。在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接受相同的信息。</p>
</li>
<li><p>总线设备：主设备和从设备</p>
</li>
</ul>
</li>
<li><p>总线特性：是指机械特性（尺寸，形状）、电器特性（传输方向和有效的电平范围）、功能特性（每根传输线的功能）和时间特性（信号和时序的关系）。</p>
</li>
<li><p>总线的猝发传输方式，在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传送。</p>
</li>
<li><p>分类</p>
<p>按功能划分为以下 3 类：</p>
<ul>
<li><p>片内总线，是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</p>
</li>
<li><p>系统总线，是计算机系统内各功能部件（CPU,主存，I/O连接）之间相互连接的总线。</p>
<p>数据通路是数据流经的路径，数据总线是承载的媒介。</p>
<p>按传送信息内容的不同，又可分为 3 类：</p>
<ul>
<li>数据总线，用来传输数据信息，是双向传输总线，其位数与机器字长、存储字长相关</li>
<li>地址总线，用来指出数据总线上的源数据或目的数据所在的主存单元或 I/O 端口的地址，是单向传输总线，地址总线的位数与主存地址空间的大小有关。</li>
<li>控制总线，用来传输控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。</li>
</ul>
</li>
<li><p>通信总线，也称为外部总线</p>
<p>通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线</p>
</li>
</ul>
</li>
<li><p>结构</p>
<ul>
<li><p>单总线结构，主存总线</p>
</li>
<li><p>双总线结构，主存总线 和 I/O 总线</p>
</li>
<li>三总线结构，主存总线，I/O总线，直接内存访问（DMA）总线</li>
</ul>
</li>
<li><p>性能指标</p>
<p>1.总线的传输周期，2.总线时钟周期，3.总线的工作频率， 4.总线的时钟频率， 5.总线宽度，6.总线带宽，7.总线复用，8.信号线数</p>
</li>
</ul>
<h3 id="2-总线仲裁"><a href="#2-总线仲裁" class="headerlink" title="2. 总线仲裁"></a>2. 总线仲裁</h3><ul>
<li><p>集中仲裁方式</p>
<ul>
<li>链式查询方式</li>
<li>计数器定时查询方式</li>
<li>独立请求方式</li>
</ul>
<p><img src="pat\cc0061.png" alt="image-20200423170626592"></p>
</li>
<li><p>分布仲裁方式</p>
</li>
</ul>
<h3 id="3-总线操作和定时"><a href="#3-总线操作和定时" class="headerlink" title="3. 总线操作和定时"></a>3. 总线操作和定时</h3><p>总线定时是指总线在双方交换数据的过程中国需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。</p>
<ul>
<li><p>总线传输的4个阶段</p>
<p>申请分配阶段，寻址阶段，传输阶段，结束阶段</p>
</li>
<li><p>同步定时方式</p>
<p>适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p>
</li>
<li><p>异步定时方式</p>
<p>根据 “请求” 和 “回答” 信号的撤销是否互锁，又可分为以下 3 种类型：</p>
<ul>
<li>不互锁方式</li>
<li>半互锁方式</li>
<li>全互锁方式</li>
</ul>
</li>
</ul>
<h3 id="4-总线标准"><a href="#4-总线标准" class="headerlink" title="4. 总线标准"></a>4. 总线标准</h3><h2 id="七、输入-输出系统"><a href="#七、输入-输出系统" class="headerlink" title="七、输入/输出系统"></a>七、输入/输出系统</h2><h3 id="1-I-O系统基本概念"><a href="#1-I-O系统基本概念" class="headerlink" title="1. I/O系统基本概念"></a>1. I/O系统基本概念</h3><ul>
<li><p>输入/输出系统</p>
<ul>
<li>1.外部设备 2.接口 3.输入设备 4.输出设备 5.外存设备</li>
<li>I/O软件，I/O硬件</li>
</ul>
</li>
<li><p>I/O控制方式</p>
<p>1）2）主要用于数据传输率较低的外部设备，3）4）主要用于数据传输率较高的设备</p>
<ol>
<li><p>程序查询方式，由CPU通过程序不断查询 I/O 设备是否已做好准备，从而控制 I/O设备与主机交换信息</p>
</li>
<li><p>程序中断方式，有在 I/O 设备准备就绪并向 CPU 发出中断请求时才予以响应</p>
</li>
<li><p>DMA方式，主存和 I/O 设备之间有一条直接数据通路，当主存和 I/O 设备交换信息时，无需调用中断服务程序。</p>
</li>
<li><p>通道方式，在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I/O 命令时，只需启动有关通道，通道将执行通道程序，从而完成 I/O 操作。</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-外部设备"><a href="#2-外部设备" class="headerlink" title="2. 外部设备"></a>2. 外部设备</h3><ul>
<li><p>输入设备</p>
<p>键盘，鼠标(机械式，光电式)</p>
</li>
<li><p>输出设备</p>
<ul>
<li><p>显示器</p>
<p>主要参数有：屏幕大小，分表率，灰度级，刷新，刷新频率，显示存储器</p>
<ul>
<li><p>阴极射线管（CRT）显示器</p>
<p>字符显示器 和 图形显示器</p>
</li>
<li><p>液晶显示器（LCD）</p>
</li>
<li><p>LED（发光二极管）显示器</p>
</li>
</ul>
</li>
<li><p>打印机</p>
<ul>
<li>针式打印机</li>
<li>喷墨式打印机</li>
<li>激光打印机</li>
</ul>
</li>
</ul>
</li>
<li><p>外存储器</p>
<p>磁盘存储器，磁盘阵列，光盘存储器，固态硬盘</p>
</li>
</ul>
<h3 id="3-I-O接口"><a href="#3-I-O接口" class="headerlink" title="3. I/O接口"></a>3. I/O接口</h3><ul>
<li><p>功能</p>
<ol>
<li>实现主机和外设的通信联络控制</li>
<li>进行地质译码和设备选择</li>
<li>实现数据缓冲</li>
<li>信号格式的转换</li>
<li>传送控制命令和状态信息</li>
</ol>
</li>
<li><p>基本结构</p>
<p><img src="pat\cc0063.png" alt="image-20200424141450489"></p>
</li>
<li><p>类型</p>
<ol>
<li>按数据传送方式可分为并行接口（一个字节或一个字的所有位同时传送）和串行接口（一位一位地传送），接口要完成数据格式的转换</li>
<li>按主机访问 I/O 设备的控制方式可分为程序查询接口，终端接口和 DMA接口等</li>
<li>按功能选择的灵活性可分为可编程接口和不可编程接口</li>
</ol>
</li>
<li><p>端口及其编址</p>
<p>对 I/O 端口的编址方式：</p>
<ul>
<li>统一编址，又称存储器映射方式</li>
<li>独立编址，又称 I/O 映射方式</li>
</ul>
</li>
</ul>
<h3 id="4-I-O方式"><a href="#4-I-O方式" class="headerlink" title="4. I/O方式"></a>4. I/O方式</h3><ul>
<li>程序查询方式</li>
<li>程序中断方式<ul>
<li>中断的基本概念</li>
<li>程序中断方式工作流程</li>
<li>多重中断和中断屏蔽技术</li>
</ul>
</li>
<li>DMA方式<ul>
<li>DMA方式的特点</li>
<li>DMA控制器的组成</li>
<li>DMA的传送方式</li>
<li>DMA的传送过程</li>
<li>DMA方式和中断方式的区别</li>
</ul>
</li>
</ul>
<h1 id="Computer-Operating-System"><a href="#Computer-Operating-System" class="headerlink" title="Computer Operating System"></a>Computer Operating System</h1><h2 id="大纲-2"><a href="#大纲-2" class="headerlink" title="大纲"></a>大纲</h2><h3 id="考查目标-2"><a href="#考查目标-2" class="headerlink" title="[考查目标]"></a>[考查目标]</h3><p>1。掌握操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。<br>2。掌握操作系统进程、内存、文件和 I/O 管理的策略、算法、机制以及相互关系。<br>3。能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用 C 语言<br>描述相关算法。</p>
<h3 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h3><p>（一）操作系统的概念、特征、功能和提供的服务<br>（二）操作系统的发展与分类<br>（三）操作系统的运行环境<br>1。内核态与用户态<br>2。中断、异常<br>3。系统调用<br>（四）操作系统体系结构</p>
<h3 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h3><p>（一）进程与线程<br>1。进程概念<br>2。进程的状态与转换<br>3。进程控制<br>4。进程组织<br>5。进程通信<br>共享存储系统；消息传递系统；管道通信。<br>6。线程概念与多线程模型<br>（二）处理机调度<br>1。调度的基本概念<br>2。调度时机、切换与过程<br>3。调度的基本准则<br>4。调度方式<br>5。典型调度算法<br>先来先服务调度算法；短作业（短进程、短线程）优先调度算法；时间片轮转调度算法；<br>优先级调度算法；高响应比优先调度算法；多级反馈队列调度算法。<br>（三）同步与互斥<br>1。进程同步的基本概念<br>2。实现临界区互斥的基本方法<br>软件实现方法；硬件实现方法。<br>3。信号量<br>4。管程<br>5。经典同步问题<br>生产者-消费者问题；读者-写者问题；哲学家进餐问题。<br>（四）死锁<br>1。死锁的概念<br>2。死锁处理策略<br>3。死锁预防<br>4。死锁避免<br>系统安全状态，银行家算法。<br>5。死锁检测和解除</p>
<h3 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h3><p>（一）内存管理基础<br>1。内存管理概念<br>程序装入与链接；逻辑地址与物理地址空间；内存保护。<br>2。交换与覆盖<br>3。连续分配管理方式<br>4。非连续分配管理方式<br>分页管理方式；分段管理方式；段页式管理方式。<br>（二）虚拟内存管理<br>1。虚拟内存基本概念<br>2。请求分页管理方式<br>3。页面置换算法<br>最佳置换算法（OPT）；先进先出置换算法（FIFO）；最近最少使用置换算法（LRU）；<br>时钟置换算法（CLOCK）。<br>4。页面分配策略<br>5。工作集<br>6。抖动</p>
<h3 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h3><p>（一）文件系统基础<br>1。文件概念<br>2。文件的逻辑结构<br>顺序文件；索引文件；索引顺序文件。<br>3。目录结构<br>文件控制块和索引节点；单级目录结构和两级目录结构；树形目录结构；图形目录结构。<br>4。文件共享<br>5。文件保护<br>访问类型；访问控制。<br>（二）文件系统实现<br>1。文件系统层次结构<br>2。目录实现<br>3。文件实现<br>（三）磁盘组织与管理<br>1。磁盘的结构<br>2。磁盘调度算法<br>3。磁盘的管理</p>
<h3 id="五、输入输出（I-O）管理"><a href="#五、输入输出（I-O）管理" class="headerlink" title="五、输入输出（I/O）管理"></a>五、输入输出（I/O）管理</h3><p>（一）I/O 管理概述<br>1.I/O 控制方式<br>2。 I/O 软件层次结构<br>（二）I/O 核心子系统<br>1.I/O 调度概念<br>2。高速缓存与缓冲区<br>3。设备分配与回收<br>4。假脱机技术（SPOOLing）</p>
<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><h2 id="大纲-3"><a href="#大纲-3" class="headerlink" title="大纲"></a>大纲</h2><h3 id="考查目标-3"><a href="#考查目标-3" class="headerlink" title="[考查目标]"></a>[考查目标]</h3><p>1。掌握计算机网络的基本概念、基本原理和基本方法。<br>2。掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特点，理<br>解典型网络设备的工作原理。<br>3。能够运用计算机网络的基本概念、基本原理和基本方法进行网络系统的分析、设计<br>和应用。</p>
<h3 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h3><p>（一）计算机网络概述<br>1。计算机网络的概念、组成与功能<br>2。计算机网络的分类<br>3。计算机网络的标准化工作及相关组织<br>（二）计算机网络体系结构与参考模型<br>1。计算机网络分层结构<br>2。计算机网络协议、接口、服务等概念<br>3.ISO/OSI 参考模型和 TCP/IP 模型</p>
<h3 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h3><p>（一）通信基础<br>1。信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念<br>2。奈奎斯特定理与香农定理<br>3。编码与调制<br>4。电路交换、报文交换与分组交换<br>5。数据报与虚电路<br>（二）传输介质<br>1。双绞线、同轴电缆、光纤与无线传输介质<br>2。物理层接口的特性<br>（三）物理层设备<br>1。中继器<br>2。集线器</p>
<h3 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h3><p>（一）数据链路层的功能<br>（二）组帧<br>（三）差错控制<br>1。检错编码<br>2。纠错编码<br>（四）流量控制与可靠传输机制<br>1。流量控制、可靠传输与滑轮窗口机制<br>2。停止-等待协议<br>3。后退 N 帧协议（GBN）<br>4。选择重传协议（SR）<br>（五）介质访问控制<br>1。信道划分<br>频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理。<br>2。随即访问<br>ALOHA 协议；CSMA 协议；CSMA/CD 协议；CSMA/CA 协议。<br>3。轮询访问<br>令牌传递协议<br>（六）局域网<br>1。局域网的基本概念与体系结构<br>2。以太网与 IEEE 802.3<br>3.IEEE 802.11<br>4。令牌环网的基本原理<br>（七）广域网<br>1。广域网的基本概念<br>2.PPP 协议<br>3.HDLC 协议<br>（八）数据链路层设备<br>1。网桥的概念和基本原理<br>2。局域网交换机及其工作原理。</p>
<h3 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h3><p>（一）网络层的功能<br>1。异构网络互联<br>2。路由与转发<br>3。拥塞控制<br>（二）路由算法<br>1。静态路由与动态路由<br>2。距离-向量路由算法<br>3。链路状态路由算法<br>4。层次路由<br>（三）IPv4<br>1.IPv4 分组<br>2.IPv4 地址与 NAT<br>3。子网划分与子网掩码、CIDR<br>4.ARP 协议、DHCP 协议与 ICMP 协议<br>（四）IPv6<br>1.IPv6 的主要特点<br>2.IPv6 地址<br>（五）路由协议<br>1。自治系统<br>2。域内路由与域间路由<br>3.RIP 路由协议<br>4.OSPF 路由协议<br>5.BGP 路由协议<br>（六）IP 组播<br>1。组播的概念<br>2.IP 组播地址<br>（七）移动 IP<br>1。移动 IP 的概念<br>2。移动 IP 的通信过程<br>（八）网络层设备<br>1。路由器的组成和功能<br>2。路由表与路由转发</p>
<h3 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h3><p>（一）传输层提供的服务<br>1。传输层的功能<br>2。传输层寻址与端口<br>3。无连接服务与面向连接服务<br>（二）UDP 协议<br>1.UDP 数据报<br>2.UDP 校验<br>（三）TCP 协议<br>1.TCP 段<br>2.TCP 连接管理<br>3.TCP 可靠传输<br>4.TCP 流量控制与拥塞控制</p>
<h3 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h3><p>（一）网络应用模型<br>1。客户/服务器模型<br>2.P2P 模型<br>（二）DNS 系统<br>1。层次域名空间<br>2。域名服务器<br>3。域名解析过程<br>（三）FTP<br>1.FTP 协议的工作原理<br>2。控制连接与数据连接<br>（四）电子邮件<br>1。电子邮件系统的组成结构<br>2。电子邮件格式与 MIME<br>3.SMTP 协议与 POP3 协议<br>（五）WWW<br>1.WWW 的概念与组成结构<br>2.HTTP 协议</p>
<h2 id="一、计算机网络体系结构-1"><a href="#一、计算机网络体系结构-1" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机网络是一些互联的、自治的计算机系统的集合.</p>
<ul>
<li><p>功能：数据通信，资源共享，分布式处理，提高可靠性，负载均衡等。</p>
</li>
<li><p>分类</p>
<ul>
<li><p>按分布范围</p>
<ol>
<li>广域网（WAN），使用交换技术</li>
<li>城域网（MAN），多采用以太网技术，因此也常并入局域网的范围进行讨论</li>
<li>局域网（LAN）,使用广播技术</li>
<li>个人区域网（PAN）,也称无线个人区域网（WPAN）</li>
</ol>
</li>
<li><p>按传输技术</p>
<p>是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别，广域网基本属于点对点网络。</p>
<ul>
<li>广播式网络</li>
<li>点对点网络</li>
</ul>
</li>
<li><p>按拓扑结构</p>
<ol>
<li><p>星形网络</p>
<p>每个终端或计算机都以单独的线路与中央设备相连，现在中央设备一般是交换机或路由器。</p>
<p>便于集中控制和管理，缺点是成本高，中心结点对故障敏感。</p>
</li>
<li><p>总线形网络</p>
<p>建网容易，增减结点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感</p>
</li>
<li><p>环形网络</p>
<p>如令牌环局域网</p>
</li>
<li><p>网状型网络</p>
<p>多仔广域网中，可靠性高，缺点是控制复杂，线路成本高。</p>
</li>
</ol>
</li>
<li><p>按使用者</p>
<ul>
<li>公用网，public</li>
<li>专用网，private</li>
</ul>
</li>
<li><p>按交换技术</p>
<ul>
<li><p>电路交换网络</p>
<p>如传统电话网络， 包括建立连接、传输数据和断开连接 三个阶段</p>
</li>
<li><p>报文交换网络，也称存储-转发网络</p>
<p>用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。</p>
</li>
<li><p>分组交换网络，也称包交换网络</p>
<p>基于报文交换网络，并且其缓冲易于管理，平均时延小，平均占用缓冲区更少，易于标准化。目前流行。</p>
</li>
</ul>
</li>
<li><p>按传输介质，有线，无线。</p>
</li>
</ul>
</li>
<li><p>计算机网络的标准化工作及相关组织</p>
<p>RFC（Request For Comments）; 4个阶段。</p>
<p>组织：ISO, ITU, IEEE</p>
</li>
<li><p>性能指标</p>
<ul>
<li><p>带宽，Bandwidth，<strong>本来</strong>表示通信线路允许通过的信号频带范围，单位是Hz。计算机网络中，带宽表示网络的通信线路所能传送数据的能力，单位是比特 b/s.</p>
</li>
<li><p>时延，Delay，包括发送时延，传播时延，处理时延和排队时延。</p>
<ul>
<li><p>发送时延 = 分组长度 / 信道宽度</p>
<p>高速链路只是减少了发送时延</p>
</li>
<li><p>传播时延 = 信道长度 / 电磁波在信道上的传播速率</p>
</li>
</ul>
</li>
<li><p>时延带宽积 = 传播时延 x 信道带宽</p>
</li>
<li><p>往返时延，RTT</p>
</li>
<li><p>吞吐量，Throughput，指单位时间内通过某个网络（或信道，接口）的数据量，受网络带宽或网络额定速率的限制。</p>
</li>
<li><p>速率，speed，单位 b/s. kb, Mb, Gb</p>
</li>
</ul>
</li>
<li><p>体系结构，层次和各层的协议及层间接口的集合。</p>
<p><img src="pat\cn0001.png" alt="image-20200426144110691"></p>
<ul>
<li><p>协议</p>
<ul>
<li>即网络协议，两个（或多个）水平实体间通信的规则的集合；</li>
<li>由三部分组成：1. 语法，规定传输数据格式 2. 语义，规定所要完成的功能 3. 同步，规定了执行各种操作的条件、时序关系等。</li>
</ul>
</li>
<li><p>接口，是同一结点内相邻两层间交换信息的连接点，是一个系统的内部规定。SAP（Service Aceess Point）</p>
</li>
<li><p>服务，是垂直的，供上层调用。服务原语有 4 类：1. 请求 2. 指示 3. 响应 4. 证实</p>
<ol>
<li><p>面向连接服务与无连接服务</p>
<p>如 TCP vs  IP、UDP</p>
</li>
<li><p>可靠服务和不可靠服务</p>
<p>只有被高一层实体 “看得见” 的功能才能称为服务</p>
</li>
<li><p>有应答服务和无应答服务</p>
<p>如，文件传输服务 vs WWW服务</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>OSI参考模型</p>
<p><img src="pat\cn0002.png" alt="image-20200426144714920"></p>
<ul>
<li>物理层，<ul>
<li>传输单位：比特，任务是透明地传输比特流</li>
<li>功能：在物理媒体上为数据端设备透明地传输原始比特流</li>
<li>接口标准：EIA-232C、EIA/TIA RS-449、CCITT的X.21等</li>
<li>研究内容<ul>
<li>一些物理媒体，不在物理层协议之内</li>
</ul>
</li>
</ul>
</li>
<li>数据链路层<ul>
<li>传输单位：帧，任务是将网络层传来的 IP 数据包组装成帧</li>
<li>功能：组帧、差错控制、流量控制和传输管理等。</li>
<li>特殊子层——介质访问子层，处理广播式网络中 如何控制对共享信道的访问 问题。</li>
<li>协议：SDLC、HDLC、PPP、STP和 帧中继等</li>
</ul>
</li>
<li>网络层<ul>
<li>传输单位：数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。</li>
<li>功能：对分组进行路由选择，并实现<strong>流量控制、拥塞控制、差错控制</strong>和网际互联等功能。<ul>
<li>因特网是由大量易购网络通过 <strong>路由器</strong>，Router相互连接起来的。因此，因特网的网络层也称网际层或IP层。</li>
</ul>
</li>
<li>协议：IP、IPX、ICMP、IGMP、ARP、RARP 和 OSPF等</li>
</ul>
</li>
<li>传输层<ul>
<li>传输单位：报文段（TPC）或用户数据报（UDP），负责主机中两个进程之间的通信</li>
<li>功能：为端到端连接提供可靠的传输服务，为端到端连接提供<strong>流量控制、差错控制、服务质量、数据传输管理</strong>等服务。</li>
<li>特点<ul>
<li>数据链路层提供的是<strong>点对点</strong>的通信，一个点指一个硬件地址或IP地址</li>
<li>传输层提供的是<strong>端对端</strong>的通信，端指的是一个点的一个端口，一个进程</li>
<li>传输层具有复用和分用的功能。</li>
</ul>
</li>
<li>协议：TPC、UDP</li>
</ul>
</li>
<li>会话层<ul>
<li>允许不同主机上的各个进程之间进行会话</li>
<li>可以使用校验点使会话在通信失效时从校验点继续恢复通信，实现数据同步</li>
</ul>
</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
<li><p>TCP / IP 模型</p>
<ul>
<li>网络接口层<ul>
<li>只是指出主机必须使用某种协议与网络连接，以便在其上传递 IP 分组。</li>
<li>功能：从主机或结点接收 IP 分组，并把它们发送到指定的物理网络上。</li>
</ul>
</li>
<li>网际层（主机-主机）<ul>
<li>TPC/IP模型的关键部分，将分组发往任何网络</li>
<li>协议：IPv4, IPv6</li>
</ul>
</li>
<li>传输层（应用-应用或进程-进程）<ul>
<li>功能：使得发送端和目的端主机上的对等实体进行会话</li>
<li>协议：TPC, UDP</li>
</ul>
</li>
<li>应用层（用户-用户）<ul>
<li>协议：Telnet、FTP、DNS、SMTP、HTTP</li>
</ul>
</li>
</ul>
</li>
<li><p>两种模型的比对</p>
<ul>
<li><p>OSI参考模型在网络层支持无连接和面向连接的通信，传输层仅有面向连接</p>
</li>
<li><p>TCP/IP模型认可可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。</p>
</li>
<li><p>学习模型</p>
<p>数据部分SDU - 加上控制信息PCI - PDU</p>
<p><img src="pat\cn0003.png" alt="image-20200426154459965"></p>
</li>
</ul>
</li>
</ul>
<h2 id="二、物理层-1"><a href="#二、物理层-1" class="headerlink" title="二、物理层"></a>二、物理层</h2><p><img src="pat\cn0007.png" alt="image-20200427084314765"></p>
<h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><ul>
<li><p>基本概念</p>
<ul>
<li><p>数据：传送信息的实体</p>
</li>
<li><p>信号：数据的电器或电磁表现，是数据在传输过程中的存在形式，有模拟信号和数字信号两种形式，传输方式有串行传输和并行传输两种方式。</p>
</li>
<li><p>码元，用一个固定时长的信号波形（数字脉冲）表示一位 k 进制数字，是数字通信中数字信号的计量单位。</p>
</li>
<li><p>一个数据通信系统主要划分为信源、信道和信宿三部分。</p>
<ul>
<li>信道有基带信道和宽带信道 及 无线信道和有线信道之分</li>
<li>交互方式：单工、半双攻、全双工</li>
<li>信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率</li>
</ul>
</li>
<li><p>速率，单位时间内传输的数据量</p>
<ul>
<li><p>码元传输速率，码元速率，波形速率</p>
<p>单位是波特（Baud），码元速率与进制无关</p>
</li>
<li><p>信息传输速率，信息速率，比特率</p>
<p>单位是比特/秒 ， b/s</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>奈奎斯特 (Nyquist) 定理</p>
<ul>
<li>理想低通信道下的极限数据传输率 = $2Wlog_2V$，单位 b/s.<ul>
<li>W 为理想低通信道的带宽，单位为 Hz</li>
<li>V 为每个码元离散电平的数目。如16种码元需要 4 位二进制位。</li>
</ul>
</li>
<li>结论：<ul>
<li>任何信道，码元传输的速率是有上限的。</li>
<li>信道的频带越宽，就可用更高的速率进行码元的有效传输</li>
<li>给出了码元传输速率的限制，但没有给出信息传输速率的限制</li>
</ul>
</li>
</ul>
</li>
<li><p>香农定理</p>
<ul>
<li>信号的极限数据传输率 = $Wlog_2(1+S/N)$，单位 b/s.<ul>
<li>W 为信道的带宽</li>
<li>S 为信道所传输信号的平均功率</li>
<li>N 为信道内部的高斯噪声功率。 S/N 为信噪比, 信噪比 = $10log_{10}(S/N)$，单位 dB。如S/N=10 时，信噪比为 10 dB， S/N = 1000时，信噪比为 30dB.</li>
</ul>
</li>
<li>结论<ol>
<li>信道的带宽或信道的信噪比越大，信息的极限传输速率越高。</li>
<li>对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</li>
<li>只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</li>
<li>实际信道能达到的传输速率要低很多</li>
<li>表明，一个码元对应的二进制位数是有限的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p>调制指把数据变换为模拟信号的过程；编码指把数据变换为数字信号的过程。</p>
<ol>
<li><p>数字数据编码为数字信号，数字发送器</p>
<p>用于基带传输，</p>
<p><img src="pat\cn0004.png" alt="image-20200426164933459"></p>
<ul>
<li>非归零编码</li>
<li>曼彻斯特编码，Manchester Encoding<ul>
<li>每个码元中间出现电平跳变</li>
<li>所占频带宽度是原始基带宽度的两倍</li>
<li>用于以太网</li>
</ul>
</li>
<li>差分曼彻斯特编码<ul>
<li>常用于局域网传输</li>
<li>可实现自同步，且抗干扰性较好</li>
</ul>
</li>
<li>4B/5B编码</li>
</ul>
</li>
<li><p>数字数据调制为模拟信号，调制器</p>
<p>调制方法有：</p>
<ul>
<li><p>幅移键控（ASK），振幅</p>
</li>
<li><p>频移键控（FSK）, 频率</p>
</li>
<li><p>相移键控（PSK），相位</p>
</li>
<li><p>正交振幅调制（QAM）,ASK 与 PSK的结合</p>
<p><img src="pat\cn0005.png" alt="image-20200426165815618"></p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>模拟数据编码为数字信号，PCM编码器</p>
<p>常用于对音频信号进行编码的脉码调制（PCM）。包括三个步骤：采样、量化和编码。</p>
<p>采样定理：</p>
<ul>
<li>$f_{采样}$必须大于等于最大频率$f$的两倍</li>
<li>又称奈奎斯特定理</li>
</ul>
</li>
<li><p>模拟数据调制为模拟信号，放大器调制器</p>
</li>
</ol>
<h3 id="电路交换、报文交换与分组交换"><a href="#电路交换、报文交换与分组交换" class="headerlink" title="电路交换、报文交换与分组交换"></a>电路交换、报文交换与分组交换</h3><ol>
<li><p>电路交换</p>
<ul>
<li>三个阶段：连接建立，数据传输，连接释放</li>
<li>优点：通信时延小，有序传输，没有冲突，使用范围广，实时性强，控制简单</li>
<li>缺点：建立连接时间长，线路独占，灵活性差，难以规格化</li>
<li>适于数据量很大且传送时间远大于呼叫时间</li>
</ul>
</li>
<li><p>报文交换</p>
<ul>
<li>优点：无需建立连接，动态分配线路，提高线路可靠性，提高线路利用率，提高多目标服务</li>
<li>缺点：存在转发延迟，要求网络节点有较大缓存空间</li>
</ul>
</li>
<li><p>分组交换</p>
<p>较先进，解决大报文传输的问题</p>
<ul>
<li>优点：无建立时延，线路利用率高，简化了存储管理，加速传输，减少了出错率和重发数据量</li>
<li>缺点：存在传输时延，需要传输额外的信息量，需对分组按编号进行排序（若采用虚电路，但有呼叫建立，数据传输和虚电路释放三个过程）</li>
<li>适于计算机之间的突发式数据通信</li>
</ul>
</li>
</ol>
<h3 id="数据报与虚电路"><a href="#数据报与虚电路" class="headerlink" title="数据报与虚电路"></a>数据报与虚电路</h3><p>面向连接的虚电路方式 和 无连接的数据报方式是分组交换的两种方式，都由网络层提供。</p>
<ul>
<li><p>数据报，存储转发</p>
</li>
<li><p>虚电路</p>
<ul>
<li>将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点。</li>
<li>三个阶段：呼叫建立，数据传输和虚电路释放</li>
<li>连接一旦建立，就固定了虚电路所对应的物理路径</li>
<li>电路并不是 专用的，</li>
</ul>
</li>
<li><p>比较</p>
<p><img src="pat\cn0006.png" alt="image-20200426173624164"></p>
</li>
</ul>
<h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><ul>
<li><p>双绞线</p>
<ul>
<li>减少相邻导线的电磁干扰<ul>
<li>绞合</li>
<li>外面加上一个金属丝编织成的屏蔽网，屏蔽双绞线（STP）,非屏蔽双绞线（UTP）</li>
</ul>
</li>
<li>通信距离 几千米到数十千米，太远时，模拟传输，用放大器放大衰减的信号；数字传输，用中继器将失真信的信号整形。</li>
<li>带宽取决于铜线的粗细和传输的距离</li>
</ul>
</li>
<li><p>同轴电缆</p>
<ul>
<li><p>组成：内导体、绝缘层、网状编织屏蔽层和塑料外层</p>
</li>
<li><p>$50\Omega$ ,传送基带数字信号，局域网和$70\Omega$传送宽带信号，有线电视系统。</p>
</li>
<li>抗干扰，广泛用于传输较高传输速率的数据，其传输距离更远，但价格较双绞线贵。</li>
</ul>
</li>
<li><p>光纤</p>
<ul>
<li>利用光导纤维传递光脉冲来进行通信，带宽范围极大</li>
<li>组成：线心和包层</li>
<li>多模光纤，从不同角度入射的多束光线可在一条光纤中传输，<ul>
<li>光源：发光二极管</li>
<li>会逐渐展宽，造成失真，只适合近距离传输</li>
</ul>
</li>
<li>单模光纤，光纤直径减小到仅一个光波长度时，不会产生多次反射。<ul>
<li>直径只有几微米，成本高</li>
<li>光源：定向性很好的激光二极管</li>
<li>衰减小，适合远距离传输</li>
</ul>
</li>
</ul>
</li>
<li><p>无线传输介质</p>
<ul>
<li>无线电波，传输距离长，向所有方向传播</li>
<li>微波、红外线和激光<ul>
<li>高带宽无线通信，</li>
<li>直线传播，又称视线介质，传输距离有限，需借助中继站来接力，如卫星。</li>
<li>卫星通信，通信容量大，距离远，覆盖广，缺点是端到端传播时延长。</li>
</ul>
</li>
</ul>
</li>
<li><p>物理层的接口特性</p>
<ul>
<li>机械特性，规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况等</li>
<li>电气特性，规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。</li>
<li>功能特性，某一电压表示意义，接口部件的信号线（数据线，定时线）的用途</li>
<li>规程特性，定义个物理线路的工作规程和时序关系。</li>
</ul>
</li>
</ul>
<h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><ul>
<li>中继器，又称转发器<ul>
<li>将信号整形并放大再转发出去</li>
<li>使用中继器连接的几个网段仍然是一个局域网，</li>
<li>工作在物理层，不能连接两个具有不同速率的局域网，没有存储转发功能，两端网段必须使用同一个协议。</li>
<li>放大器放大模拟信号（将信号放大），中继器放大数字信号（信号整形再生）</li>
</ul>
</li>
<li>集线器 Hub<ul>
<li>多端口中继器，工作在物理层</li>
<li>扩大网络传输范围，</li>
<li>主要使用双绞线组建共享网络</li>
<li>只能工作在半双工状态</li>
</ul>
</li>
</ul>
<h2 id="三、数据链路层-1"><a href="#三、数据链路层-1" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h2><p>本章是历年考察重点，研究的是 “点到点” 之间的通信。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<ol>
<li><p>为网络层提供服务</p>
<ul>
<li>无确认的无连接服务，适用于实时通信 或 误码率较低的通信信道，如以太网</li>
<li>有确认的无连接服务，适用于误码率较高的通信信道，如无线通信</li>
<li>有确认的面向连接服务，适用于通信要求（可靠性、实时性）较高的场合。有连接就一定有确认。</li>
</ul>
</li>
<li><p>链路管理</p>
</li>
<li>帧定界、帧同步与透明传输，HDLC通信中，用标识位 F（01111110）来标识帧的开始和结束。</li>
<li>流量控制，限制发送方的数据流量，使其发送速率不超过接收方的接收能力。</li>
<li>差错控制<ul>
<li>位错，CRC检错，ARQ重传出错帧</li>
<li>帧错，引入定时器和编号机制</li>
</ul>
</li>
</ol>
<h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p>组帧主要解决帧定界、帧同步、透明传输等问题。网络信息传输的最小单位是 帧。</p>
<ol>
<li>字符计数法，帧头设置计数字段。</li>
<li>字符填充的首尾定界符法，使用特殊字符：开始（DLE STX）结束（DLE ETX）.</li>
<li>比特填充的首尾标志法，使用 01111110标志开始和结束。容易由硬件实现，性能优于字符填充.常用。</li>
<li>违规编码法，借用违规编码序列定始终。如局域网IEEE 802。只适用于采用冗余编码的特殊编码环境，常用。</li>
</ol>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><ol>
<li>检错编码<ul>
<li>奇偶校验码</li>
<li>循环冗余码</li>
</ul>
</li>
<li>纠错编码<ul>
<li>海明码</li>
</ul>
</li>
</ol>
<h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><ol>
<li><p>流量控制、可靠传输 与 滑动窗口机制</p>
<p>流量控制的基本方法是由接收方控制发送方发送数据的速率，常见方式有：停止-等待协议和滑动窗口协议。</p>
<ul>
<li><p>停止-等待流量控制基本原理，每次只发送一帧，然后等待反馈。</p>
</li>
<li><p>滑动窗口流量控制基本原理，</p>
<ul>
<li><p>发送窗口$W_T$代表在还未收到对方确认信息的情况下发送方最多还可以发送多个数据帧。</p>
</li>
<li><p>接受窗口，控制可以 接收/抛弃 哪些数据帧，</p>
</li>
<li><p>接收窗口大小为 1 时，可保证帧的有序接受</p>
</li>
<li><p>窗口的大小在传输过程中是固定的，与 传输层的滑动窗口协议的区别</p>
<p>停止-等待协议：$W_T=1,W_R=1$</p>
<p>后退 N 帧协议：$W_T&gt;1,W_R=1$</p>
<p>选择重传协议：$W_T&gt;1,W_R&gt;1$</p>
</li>
</ul>
</li>
<li><p>可靠重传机制</p>
<p>数据链路层的可靠性传输通常使用确认和超时重传两种机制来完成。</p>
<ul>
<li><p>确认，捎带确认</p>
</li>
<li><p>超时重传，发送方设置计时器</p>
</li>
<li><p>自动重传请求（ARQ），接收方请求出错帧。传统自动重传请求分三种：</p>
<ul>
<li>Stop-and-Wait ARQ</li>
<li>Go-Back_N ARQ</li>
<li>选择性重传ARQ</li>
</ul>
<p>数据链路层中流量控制和可靠传输是交织在一起的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单帧滑动窗口 与 停止-等待协议</p>
<ul>
<li>用 1 bit 对帧编号</li>
<li>每发送一个数据帧就停止并等待。</li>
</ul>
<p><img src="pat\cn0008.png" alt="image-20200427103643333"></p>
</li>
<li><p>多帧滑动窗口 与 后退 N 帧协议（GBN）</p>
<ul>
<li><p>接收方只允许按顺序接收帧；</p>
</li>
<li><p>接收端可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认信息。</p>
</li>
<li><p>若采用 n 比特对帧编号，发送窗口大小应满足 $1\le W_T\le 2^n-1$。</p>
</li>
<li>会有 在重传时 必须把原来已经传送正确的数据帧进行重传 的现象。</li>
<li>累计确认</li>
</ul>
<p><img src="pat\cn0009.png" alt="image-20200427104422021"></p>
</li>
<li><p>多帧滑动窗口 与选择重传协议（SR）</p>
<ul>
<li><p>只重传出现差错的数据帧或计时器超时的数据帧</p>
</li>
<li><p>更有效的差错处理策略，一旦接收方怀疑帧出错，就会发送一个否定帧 NAK给发送方，重传。</p>
</li>
<li><p>窗口需满足: $W_R+W_T\le 2^n \quad,W_R\le 2^{n-1}\le W_T$</p>
</li>
<li><p>接受窗口为最大值时，$W<em>{Tmax}=W</em>{Rmax}=2^{n-1}\quad,一般地 W_T = W_R$</p>
<p><img src="pat\cn0010.png" alt="image-20200427104929766"></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>信道效率</strong>，也称信道利用率，从时间角度的定义：信道效率是对发送方而言的，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。</li>
<li>信道吞吐率 = 信道利用率 x 发送方的发送速率。</li>
</ul>
<h3 id="介质访问控制，"><a href="#介质访问控制，" class="headerlink" title="介质访问控制，"></a>介质访问控制，</h3><p>MAC子层，任务是为使用介质的每个结点 隔离 来自同一信道上其它结点所传送的信号，决定广播信道中信道分配。</p>
<ol>
<li><p>信道划分介质访问控制</p>
<p>信道划分实质就是通过分时，分频，分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道。</p>
<p><img src="pat\cn0011.png" alt="image-20200427124918089"></p>
<ul>
<li>频分多路复用（FDM）,静态<ul>
<li>相邻信道之家需加入“保护频带”，防止信道间相互干扰</li>
<li>充分利用传输介质的带宽，系统效率较高；技术成熟，容易实现</li>
<li>共享时间，而不共享空间</li>
</ul>
</li>
<li>时分多路复用（TDM），静态<ul>
<li>一条物理信道按时间片 轮流地分配给多个信号使用。</li>
<li>统计时分多路复用（STDM，又称异步时分多路复用）是TDM的一种改进，采用STDM帧，不固定分配时隙，而按需动态地分配时隙。可相对提高线路的利用率。</li>
<li>共享空间，而不共享时间</li>
</ul>
</li>
<li>波分多路复用（WDM），动态<ul>
<li>即光的频分多路复用，波长分解复用器</li>
<li>即共享空间，又共享时间。黄豆与绿豆在同一辆车运送，到达 C 站后再分开。</li>
</ul>
</li>
<li>码分多路复用（CDM），动态<ul>
<li>采用不同编码。即共享信道的频率，又共享时间。</li>
<li>合波器，分波器</li>
<li>码分多址（CDMA）,一种方式。码片（Chip）</li>
<li>频谱利用率高、抗干扰能力强、语音质量好等优点，还可以减少投资和降低运行成本，主要用于无线通信系统，特别是移动通信系统。</li>
</ul>
</li>
</ul>
</li>
<li><p>随机访问介质访问控制</p>
<ul>
<li><p>info</p>
<ul>
<li>解决随机接入发生的碰撞，每个用户需要按照一定的规则反复地重传它的帧，直到无碰撞地通过。</li>
<li>常用协议核心思想都是：胜利者通过争用获得信道，从而获得信息的发送权，因此，随机访问介质控制协议又称 <strong>争用协议</strong>。</li>
<li>是一种将广播信道转化为点到点信道的行为。</li>
</ul>
</li>
<li><p>ALOHA协议， Additive Link On-line HAwaii system.</p>
<ul>
<li>纯ALOHA协议<ul>
<li>重传策略，让各站等待一段随机的时间，直到重传成功。</li>
<li>吞吐量 $S=Ge^{-2G},\quad G为网络负载$</li>
</ul>
</li>
<li>时隙ALOHA协议<ul>
<li>规定只能在每个时隙开始时才能发送一个帧</li>
<li>$S=Ge^{-G}$，比纯ALOHA网络的吞吐量大了 1 倍。</li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA协议，载波侦听多路访问（Carrier Sense Multiple Access, CSMA）</p>
<p><img src="pat\cn0012.png" alt="image-20200428084737956"></p>
<ol>
<li><p>1-坚持 CSMA</p>
<p>侦听到信道忙后，继续坚持侦听信道；侦听到信道空闲后，发送帧的概率为 1。</p>
</li>
<li><p>非坚持CSMA</p>
<p>如果信道忙，那么放弃侦听，等待一个随机的时间再继续侦听，若空闲，立即发送。</p>
</li>
<li><p>p-坚持CSMA</p>
<ul>
<li>用于时分信道</li>
<li>若忙，等待下一个时隙再侦听；若空闲，以概率 p 发送数据，以概率 1-p 推迟到下一个时隙</li>
</ul>
</li>
</ol>
</li>
<li><p>CSMA/CD 协议，载波侦听多路访问/碰撞检测（CSMA with Collision Detection）</p>
<ul>
<li>适用于总线形网络或半双工网络环境</li>
<li>碰撞检测，就是边发送边侦听</li>
<li>工作流程可简单概括为：先听后发，边听边发，冲突停发，随机重发。<ul>
<li>传输拥塞信号后，适配器采用 <strong>截断二进制指数退避算法</strong> 等待一段随机事件<ul>
<li>重传所需的退避时间就是 r 倍的基本退避时间。</li>
</ul>
</li>
</ul>
</li>
<li>总线的传播时延对 CSMA/CD的影响很大，采用CSMA/CD协议的以太网不可能进行全双工通信，只能进行半双工通信。<ul>
<li>设$\tau$为单程传播时延，以太网端到端往返时间$2\tau$为争用期，（又称冲突窗口或碰撞窗口）</li>
<li>最小帧长 = 总线传播时延 x 数据传输率 x 2</li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA/CA 协议，载波侦听多路访问/碰撞避免（CSMA with Collision Avoidance）</p>
<ul>
<li>CSMA/CD协议已成功应用于使用<strong>有线连接的局域网</strong>，CSMA/CA应用于<strong>无线网</strong></li>
<li>采用二进制指数退避算法，当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不使用退避算法</li>
<li>三种机制来实现碰撞避免<ul>
<li>预约信道</li>
<li>ACK帧</li>
<li>RTS/CTS 帧，可选，主要用于解决无线网中的 “隐蔽站” 问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>轮询访问介质访问控制</p>
<ul>
<li>典型协议是 令牌传递协议，主要用在令牌环局域网。</li>
<li><p>令牌是由一组特殊的比特组合而成的帧，只有拿到令牌的计算机才可以发送数据帧</p>
</li>
<li><p>适合负载很高的广播信道，即指多个结点在同一时刻发送数据概率很大的信道。</p>
</li>
</ul>
</li>
</ol>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>要熟悉局域网的各种协议.</p>
<ul>
<li><p>基本概念和体系结构</p>
<ul>
<li><p>特点    </p>
<ol>
<li>为一个单位所拥有，且地理范围和站点数目均有限</li>
<li>所有站点共享较高的总带宽（即较高的数据传输率）</li>
<li>较低的时延和较低的误码率</li>
<li>各站为平等关系而非主从关系</li>
<li>能进行广播和组播</li>
</ol>
</li>
<li><p>局域网的特性主要由三个要素决定</p>
<ul>
<li><p>拓扑结构</p>
<p>星形、环形、总线形，星形和总线形结合的复合型</p>
</li>
<li><p>传输介质</p>
<p>双绞线（主流）、铜缆和光纤等</p>
</li>
<li><p>介质访问控制方式，最重要，决定技术特性</p>
<p>CSMA/CD、令牌总线和令牌网，前两种主用于总线形网络，令牌环主要用于环形局域网</p>
</li>
</ul>
</li>
<li><p>三种特殊的局域网拓扑实现</p>
<ul>
<li>以太网（使用范围最广），逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构</li>
<li>令牌环（Token Ring,IEEE 802.5）,逻辑拓扑是环形结构，物理拓扑是星形结构</li>
<li>FDDI（光纤分布数字接口，IEEE 802.8）,逻辑拓扑是环形结构，物理拓扑是双环结构</li>
</ul>
</li>
<li><p>IEEE 802</p>
<ul>
<li>局域网参考模型只对应与OSI的数据链路层和物理层</li>
<li>由于以太网的垄断地位，几乎成为局域网的代名词，802 LLC子层作用已经不大，现在许多网卡仅装有 MAC 协议而没有 LLC 协议。</li>
<li>逻辑链路控制（LLC）子层<ul>
<li>向网路层提供无确认无连接、带确认无连接、面向连接、高速传送服务</li>
</ul>
</li>
<li>媒体介入控制（MAC）子层<ul>
<li>功能：组帧和拆卸帧、比特传输差错检测、透明传输</li>
</ul>
</li>
</ul>
<p><img src="pat\cn0013.png" alt="image-20200428095512983"></p>
</li>
</ul>
</li>
<li><p>以太网 与 IEEE 802.3 </p>
<ul>
<li><p>Intro</p>
<ul>
<li>IEEE 802.3标准是一种基带总线形的局域网标准，描述物理层和数据链路层的MAC子层的实现方法。</li>
<li>以太网逻辑上总线形拓扑，所有计算机共享一条总线，信息以广播方式发送，使用CSMA/CD方式对总线进行访问控制，符合DIX Ethernet V2标准，（与IEEE 802.3差别很小，故802.3 局域网常简称为以太网）</li>
<li>以太网简化通信，采用无连接的工作方式，不发送数据帧编号，不要求接收方发送确认，最大努力交付数据，提供不可靠服务，差错的纠正由高层完成。</li>
</ul>
</li>
<li><p>以太网的传输介质与网卡</p>
<ul>
<li>使用集线器的以太网仍是一个总线网，属于一个冲突域。</li>
<li>网卡，网络适配器（Adapter）或网络接口卡（NIC）<ul>
<li>是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</li>
<li>每个网卡有一个唯一代码，称为 介质访问控制（MAC）地址。该地址用于控制主机在网络上的数据通信。</li>
<li>工作在物理层，只关注比特。</li>
</ul>
</li>
</ul>
<p><img src="pat\cn0014.png" alt="image-20200428102623898"></p>
</li>
<li><p>以太网的MAC帧</p>
<ul>
<li><p>MAC地址，又称物理地址，长 6 字节。高24位为厂商代码。</p>
</li>
<li><p>两种标准：DIX Ethernet V2 和 IEEE 802.3</p>
<ul>
<li>有CSMA/CD算法可知以太网帧的最短帧长为 64B，MAC帧的首尾部长度为18B. 所以数据最短为 46B，最大 1500B是规定，没有为什么。</li>
</ul>
<p><img src="pat\cn0015.png" alt="image-20200428171155374"></p>
</li>
</ul>
</li>
<li><p>高速以太网</p>
<p>速率达到或超过 100Mb/s的以太网称为高速以外网</p>
<ul>
<li>100BASE-T 以太网</li>
<li>吉比特以太网</li>
<li>10 吉比特以太网</li>
</ul>
</li>
</ul>
</li>
<li><p>IEEE 802.11</p>
<ul>
<li>是无线局域网的一系列协议标准</li>
<li>采用CAMA/CA协议</li>
<li>有固定基础设施无线局域网<ul>
<li>基本服务及（Basic Service Set, BSS）,一个基站（接入点Access Point, AP，作用和网桥类似），若干移动站。</li>
<li>主干分配系统（Distribution System, DS）</li>
<li>扩展的服务集（Extended Service Set, ESS）,可通过门桥（Portal，作用相当于网桥）为无线用户提高到非 802.11 无线局域网的接入</li>
<li><img src="pat\cn0016.png" alt="image-20200429092459143"></li>
</ul>
</li>
<li>无固定基础设施无线局域网自组织网络<ul>
<li>没有接入点（AP）</li>
<li>与移动IP并不相同</li>
<li>具有自己特定的路由选择协议，可以不和因特网相连</li>
<li><img src="pat\cn0017.png" alt="image-20200429092805026"></li>
</ul>
</li>
</ul>
</li>
<li><p>令牌环网的基本原理</p>
<p><img src="pat\cn0018.png" alt="image-20200429095540715"></p>
<ul>
<li>物理上采用星形拓扑结构，逻辑上仍是环形拓扑结构，其标准由IEEE 802.5 定义。</li>
</ul>
</li>
</ul>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><ul>
<li><p>基本概念</p>
<ul>
<li>广域网是因特网的核心部分，任务是长距离运送主机所发送的数据。</li>
<li><p><img src="pat\cn0019.png" alt="image-20200429100006944"></p>
</li>
<li><p>广域网由一些结点交换机及连接这些交换机的链路组成。</p>
<ul>
<li>结点交换机在单个网络中转发分组，结点之间都是点到点相连。</li>
<li>路由器在多个网络构成的互联网中转发分组</li>
<li>路由选择（形成路由表和转发表），分组转发</li>
<li><img src="pat\cn0020.png" alt="image-20200429100507827"></li>
</ul>
</li>
<li>PPP协议 和 HDLC协议是常用的两种广域网数据链路层控制协议</li>
</ul>
</li>
<li><p>PPP协议，（Point-to-Point Protocol）</p>
<ul>
<li><p>面向字节</p>
</li>
<li><p>设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各主机、网桥和路由器之间简单连接的一种共同的解决方案。</p>
</li>
<li><p>三部分</p>
<ol>
<li>链路控制协议（LCP）</li>
<li>网络控制协议（NCP）</li>
<li>一个将 IP 数据报封装到串行链路的方法。信息部分长度受MTU限制。</li>
</ol>
</li>
<li><p>PPP 帧的格式</p>
<p><img src="pat\cn0021.png" alt="image-20200429160615589"></p>
</li>
<li><p>PPP 是点对点，不是总线，无须采用CSMA/CD协议，没有最短帧一说，所以信息段占0-1500B</p>
</li>
</ul>
</li>
<li><p>HDLC协议，高级数据链路控制（High-level Data Link Control, HDLC）</p>
<ul>
<li><p>面向比特</p>
</li>
<li><p>基于两种配置，非平衡配置和平衡配置</p>
</li>
<li><p>3 种站类型：主站（命令帧）、从站（响应帧）和复合站（命令帧和复合帧）。</p>
</li>
<li><p>3 中数据操作方式：正常响应方式，异步平衡方式，异步响应方式</p>
</li>
<li><p>HDLC帧</p>
<p><img src="pat\cn0022.png" alt="image-20200430082753490"></p>
<p><img src="pat\cn0023.png" alt="image-20200430083017108"></p>
</li>
</ul>
</li>
</ul>
<h3 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h3><p><img src="pat\cn0024.png" alt="image-20200430085021594"></p>
<ul>
<li><p>网桥的概念及其基本原理</p>
<ul>
<li>Intro<ul>
<li>网桥工作在链路层的 MAC 子层，可以使以太网各网段成为隔离开的碰撞域</li>
<li>网桥处理数据的对象是帧，中继器、放大器处理数据的对象是信号，所以它们是工作在物理层 的设备。</li>
<li>网桥的基本特点，见书。</li>
<li>网桥的优缺点，见书。</li>
</ul>
</li>
</ul>
<ol>
<li>透明网桥（选择的不是最佳路由）</li>
<li>源路由网桥（选择的是最佳路由）</li>
<li>两种网桥的比较</li>
</ol>
</li>
<li><p>局域网交换机及其工作原理</p>
<ol>
<li>局域网交换机<ul>
<li>工作在数据链路层</li>
<li>虚拟局域网（Virtual LAN，VLAN）不仅可以隔离冲突域，而且可以隔离广播域</li>
</ul>
</li>
<li>原理</li>
<li>特点，见书</li>
<li>两种交换模式<ul>
<li>直通式</li>
<li>存储转发式</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="四、网络层-1"><a href="#四、网络层-1" class="headerlink" title="四、网络层"></a>四、网络层</h2><p><img src="pat\cn0025.png" alt="image-20200430090318841"></p>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><ol>
<li>异构网络互联<ul>
<li>网络互联通常是指用路由器进行网络互联和路由选择</li>
<li>虚拟互联网络也就是逻辑互联网络，可简称为 IP网络</li>
<li>中间设备，中间系统，中继系统<ol>
<li>物理层：中继器，集线器（Hub）</li>
<li>数据链路层中继系统：网桥或交换机</li>
<li>网络层：路由器</li>
<li>网络层以上：网关</li>
</ol>
</li>
</ul>
</li>
<li>路由与转发<ul>
<li>路由选择，路由选择协议，生成路由表</li>
<li>分组转发，转发表由路由表得出。</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>随着网络负载的增加，网络吞吐量可能进入的状态：轻度拥塞，拥塞，死锁</li>
<li>作用是确保子网能够承载所达到的流量，这是一个全局性的过程，涉及网络中所有主机、路由器及导致网络传输能力下降的所有因素。</li>
<li>方法<ul>
<li>开环控制，静态预防方法，在做决定时不考虑当前网络的状态</li>
<li>闭环控制，动态方法，基于反馈环路的概念</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><ol>
<li><p>静态路由与动态路由</p>
<p>常见的动态路由算法分两类：距离-向量路由算法 和 链路状态路由算法</p>
</li>
<li><p>距离-向量路由算法</p>
<ul>
<li>常见算法是 RIP算法，它采用 “条数” 作为距离的度量</li>
<li>最短（最小代价）通路</li>
</ul>
</li>
<li><p>链路状态路由算法</p>
<ul>
<li>典型算法是 OSPF算法</li>
<li>Dijsktra最短路径算法计算路由</li>
</ul>
</li>
<li><p>层次路由</p>
</li>
</ol>
<h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><ol>
<li><p>IPv4分组</p>
<ul>
<li><p>IPv4分组的格式</p>
<ul>
<li>固定部分为 20 B.</li>
<li>首部长度，总长度，片偏移的单位分别为 4B, 1B, 8B</li>
<li>fields<ul>
<li>首部长度，16位，指首部和数据之和的长度，单位字节，最大长度 65535B.以太网帧的最大传输单元（MTU）为1500B.</li>
<li>标识，16位，计数器，每产生一个数据报就加 1，分片的多个数据报标识相同。</li>
<li>标志，3位，最低位 MF: 1 表示还有分片 0 表示最后一个分片。中间位 DF：为 0 时才允许分片。</li>
<li>片偏移，13位，分片后，某片在原分组中的相对位置。单位 8 B，即分片长度为 8B（64位）的整数倍</li>
<li>生存时间（TTL），8位，数据报在网络中可通过的路由器数的最大值。</li>
<li>协议，6为TCP，17为UDP</li>
</ul>
</li>
</ul>
<p><img src="pat\cn0026.png" alt="image-20200507090311736"></p>
</li>
<li><p>IP数据报分片</p>
<ul>
<li>目的主机使用 IP 首部中的标识、标志和片偏移字段来完成对片的重组。</li>
</ul>
</li>
<li><p>网络层转发分组的流程</p>
<p><img src="pat\cn0027.png" alt="image-20200507093828622"></p>
<ul>
<li>将 IP 地址转换成 MAC 地址，将其放到 MAC 帧首部中，然后根据这个 MAC 地址找到下一条路由器。</li>
<li>不同网络中传送时，MAC帧中的源地址和目的地址要发生变化</li>
<li>网桥在转发帧时，不改变帧的源地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>IPv4地址与NAT</p>
<ul>
<li><p>IPv4地址</p>
<ul>
<li>IP 地址::= {&lt;网络号&gt;, &lt;主机号&gt;}</li>
</ul>
<p><img src="pat\cn0028.png" alt="image-20200507094559674"></p>
<ul>
<li><p>主机号全为 0 表示本网络本身</p>
</li>
<li><p>主机号全为 1 表示本网络的广播地址，又称直接广播地址</p>
</li>
<li><p>127.0.0.0 保留为环路自检地址，表示任意主机本身</p>
</li>
<li><p>32位全为0， 0.0.0.0 表示本网络上的本主机</p>
</li>
<li><p>32位全为1， 255.255.255.255 表示整个 TCP/IP网络的广播地址，又称受限广播地址。由于路由器对广播域的隔离，其等效为本网络的广播地址。</p>
<p><img src="pat\cn0029.png" alt="image-20200507095309348"></p>
</li>
<li><p>A 减2，全 0 为保留地址，网络号为 127 的 IP 地址是环回测试地址</p>
</li>
<li><p>B 减1,128.0 网络号不可指派 / 65534</p>
</li>
<li><p>C 减1,192.0.0的网络不可指派 / 254</p>
</li>
</ul>
</li>
<li><p>IP地址的特点</p>
<ul>
<li>路由器至少具有两个IP地址，也至少有多个硬件地址</li>
</ul>
</li>
<li><p>网络地址转换（NAT）</p>
<p>指通过将专用网络地址（如Intranet）转换为公用地址（Internet）,对外隐藏内部管理的IP地址。</p>
<ul>
<li><p>路由器对目的地址是私有地址的数据报一律不进行转发</p>
</li>
<li><p>专用互联网或本地互联网，私有IP地址也称为可重用地址</p>
</li>
<li><p>NAT 转换表 完成 本地地址 与 全球地址的相互转换，</p>
</li>
<li><p>通过{本地IP地址 : 端口} - {全球IP地址: 端口}</p>
</li>
<li><p>普通路由器（仅在网络层）在转发 IP 数据报时，不改变其源 IP 地址和目的地址。而NAT路由器在转发 IP 数据报时，一定要更换其IP地址。</p>
<p><img src="pat\cn0030.png" alt="image-20200507110459561"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>子网划分与子网掩码、CIDR</p>
<ul>
<li><p>子网划分</p>
<ul>
<li>子网划分纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络</li>
<li>IP 地址 = {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}</li>
<li>划分子网只是把 IP 地址的主机号这部分进行再划分。</li>
<li>全0 或 全1的子网号 是否可用取决于路由器所用的路由选择软件是否支持全0 或全1</li>
<li>子网中主机号全0的地址为子网的网络号，主机号全1的地址为子网的广播地址，不能被指派。</li>
</ul>
</li>
<li><p>子网掩码</p>
<ul>
<li>使用子网掩码来表达对原网络中主机号的借位。IP 地址与子网掩码逐位 “与”，便可得出相应子网的网络地址。</li>
<li>默认子网掩码，</li>
<li>路由表中信息内容，目的网络地址、子网掩码、下一跳地址</li>
</ul>
</li>
<li><p>无分类域间路由选择（CIDR）</p>
<p>无域间路由选择是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种 IP 地址的划分方法。</p>
<ul>
<li>IP 地址的无分类两级编址 IP::={&lt;网络前缀&gt;,&lt;主机号&gt;}</li>
<li>CIDR还是用 “斜线记法” 或称（CIDR记法），即 IP 地址/网络前缀所占比特数</li>
<li>CIDR不使用子网，但仍然使用 “掩码” 一词。</li>
<li>CIDR地址块，路由聚合，或称构成超网，有利于减少路由器之间的路由选择信息的交换，从而提高网络性能。</li>
<li>使用CIDR时，路由表每项由 “网络前缀” 和 “下一条地址” 组成，选择路由时 使用最长前缀匹配（最佳匹配），更精确。</li>
<li>CIDR查找路由的方法，自上而下层次查找，无分类编址的路由表，二叉线索数据结构</li>
</ul>
</li>
</ul>
</li>
<li><p>ARP、DHCP与ICMP</p>
<ul>
<li><p>IP地址与硬件地址</p>
<ul>
<li>IP分组在每个网络中都被路由器解封装和重新封装，其数据链路层封装所使用的MAC地址是不断改变的，这也决定了无法使用MAC地址跨网络通信。</li>
</ul>
</li>
<li><p>地址解析协议（Address Resolution Protocol, ARP）</p>
<ul>
<li>完成 IP 地址到 MAC 地址的映射</li>
<li>每台主机都设有一个 ARP 高速缓冲，用来存放本局域网上各主机和路由器的 IP 地址和 MAC 地址的映射表，称 ARP 映射表，使用 ARP 来动态维护。</li>
<li>ARP “看到了” IP地址 工作在网络层，NAT路由器 “看到了” 端口 工作在传输层。</li>
<li>使用目的MAC地址为 FF-FF-FF-FF-FF-FF的帧广播</li>
</ul>
</li>
<li><p>动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）</p>
<ul>
<li>常用于给主机动态地分配 IP 地址，</li>
<li>应用层协议，基于 UDP</li>
<li>工作原理<ul>
<li>客户/服务器方式</li>
<li>DHCP服务器的回答报文称为提供报文</li>
<li>DHCP发现消息 - DHCP提供消息 -  DHCP请求消息 - DHCP确认消息</li>
</ul>
</li>
<li>租用期</li>
</ul>
</li>
<li><p>网际控制报文协议（Internet Control Message Protocol, ICMP）</p>
<p>让主机或路由器报告差错和异常情况</p>
<ul>
<li><p>IP 层协议</p>
</li>
<li><p>A. ICMP差错报告报文</p>
<p>1.终点不可达 2.源点抑制 3.时间超过 4.参数问题 5.改变路由（重定向）</p>
</li>
<li><p>B. ICMP询问报文</p>
<ul>
<li>1.回送请求和回答报文 2.时间戳请求和回答报文 3.掩码地址请求和回答报文 4.路由器询问和通告报文。前两类常用。</li>
<li>常见应用粉组网间探测PING（应用层，B1） 和 Traceroute（网络层 A3）.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>IPv6</p>
<ol>
<li>IPv6的主要特点<ul>
<li>16B, 128位，首部长度时 8B 的整数倍</li>
</ul>
</li>
<li>IPv6地址<ul>
<li>每 4 位用一个十六进制数表示，并用冒号分隔每 16 位</li>
</ul>
</li>
</ol>
</li>
<li><p>路由协议</p>
<ol>
<li><p>自治系统（Autonomous System, AS）</p>
<ul>
<li>单一技术管理下的一组路由器</li>
</ul>
</li>
<li><p>域内路由与域间路由</p>
<ul>
<li>内部网关协议（Interior Gateway Protocol, IGP）<ul>
<li>使用最多，如 RIP 和 OSPF</li>
</ul>
</li>
<li>外部网关协议（External Gateway Protocol, EGP）<ul>
<li>使用最多的是 BGP-4</li>
</ul>
</li>
</ul>
</li>
<li><p>路由信息协议（Routing Information Protocol, RIP）</p>
<p>RIP 是一种分布式的基于距离向量的路由选择协议，最大优点就是简单。</p>
<ul>
<li>RIP规定<ol>
<li>距离向量，跳数</li>
<li>距离等 16，表示网络不可达，因而 RIP 只适合小型互联网</li>
</ol>
</li>
<li>RIP的特点（注意与OSPF的特点比较）<ol>
<li>仅和相邻路由器交换信息</li>
<li>RIP 收敛</li>
<li>RIP是应用层协议，使用UDP传送数据（端口520）。</li>
</ol>
</li>
<li>距离向量算法<ul>
<li>每个路由表项: &lt;目的网络 N, 距离 d, 下一跳路由器 X&gt;</li>
<li>RIP 默认超时时间为 180 s.</li>
<li>步骤见书 P178</li>
</ul>
</li>
</ul>
</li>
<li><p>开发最短路径优先（OSPF）协议</p>
<p>使用分布式链路状态路由算法.</p>
<ul>
<li>OSPF协议的基本特点<ul>
<li>洪泛法</li>
<li>“链路状态” 说明本路由器和哪些路由器相邻及该链路的 “度量”（或代价）</li>
<li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li>
<li>OSPF是网络层协议，直接使用 IP 数据报传送（其 IP 数据报首部的协议字段为 89）</li>
<li>根据 IP 分组的不同服务类型（TOS）而设置成不同的代价。</li>
<li>多路径间的负载平衡</li>
<li>每个链路状态都有一个 32 的序号，序号越大，状态就越新。</li>
</ul>
</li>
<li>OSPF的基本工作原理<ul>
<li>链路状态数据库，即全网的拓扑结构图，在全网内是一致的。</li>
<li>每个路径根据该全网拓扑结构图，使用 Dijkstra 最短路径算法计算最优路径以构造路由表。<strong>路由表只存储 “下一跳”</strong></li>
<li>区域，将利用洪泛法交换链路状态信息的范围局限于每个区域而非整个自治系统，减少了这个网络上的通信量。主干区域。</li>
</ul>
</li>
<li>OSPF的五种分组类型<ol>
<li>问候分组</li>
<li>数据库描述分组</li>
<li>链路状态请求分组</li>
<li>链路状态更新分组</li>
<li>链路状态确认分组</li>
</ol>
</li>
</ul>
</li>
<li><p>边界网关协议（Border Gateway Protocol, BGP）</p>
<ul>
<li>Intro<ul>
<li>BGP 是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。</li>
<li>常用于互联网的网关之间</li>
<li>路由表包含，1）已知路由器的列表 2）路由器能达到的地址及到达每个路由器的路径的跳数</li>
<li>BGP 只能力求寻找一条能够到达目的网络且比较好的路由，而非寻找一条最佳路由。</li>
<li>采用路径向量路由选择协议，应用层协议，基于 TCP</li>
</ul>
</li>
<li>工作原理<ul>
<li>BGP 所交换的网络可达性信息就是要到达某个网络所要经过的一系列 AS.</li>
<li>BGP 支持 CIDR, 路由表项包括目前的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列</li>
<li>BGP-4使用 4 中报文<ol>
<li>打开（Open）报文</li>
<li>更新（Update）报文</li>
<li>保活（Keepalive）报文</li>
<li>通知（Notification）报文</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="pat\cn0031.png" alt="image-20200509143825526"></p>
</li>
</ol>
</li>
<li><p>IP组播</p>
<ol>
<li>组播的概念<ul>
<li>组播机制是为了能够支持像视频点播和视频会议这样的多媒体应用</li>
<li>仅应用于 UDP</li>
<li>组播地址表示一组地址，在 D 类地址空间空分配。</li>
<li>主机使用一个称为 IGMP（因特网组管理协议）的协议加入组播组。</li>
<li>组播需要路由器的支持才能实现，组播路由器。</li>
</ul>
</li>
<li>IP组播地址<ul>
<li>D 类地址范围是 224.0.0.0 - 239.255.255.255，一个 D 类 IP 地址标志一个组播组。</li>
<li>组播数据报，首部中协议字段值是 2. 表明使用 IGMP.</li>
<li>IP 组播分为两种<ol>
<li>只在本局域网上进行硬件组播</li>
<li>在因特网的范围内进行组播</li>
</ol>
</li>
<li>组播 IP 地址与以太网硬件地址的映射关系不是唯一的。</li>
</ul>
</li>
<li>IGMP与组播路由算法<ul>
<li>因特网组管理协议（Internet Group Management Protocol, IGMP），使路由器知道组播成员的信息</li>
<li>组播路由选择协议<ul>
<li>组播路由选择实际上就是要找出以源主机为根节点的组播转发树，</li>
</ul>
</li>
<li>IGMP 让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组。</li>
</ul>
</li>
</ol>
</li>
<li><p>移动IP</p>
<ol>
<li>移动 IP 的概念<ul>
<li>移动 IP，支持移动性的因特网体系结构与协议；</li>
<li>区别与移动自网络</li>
<li>区别与动态 IP</li>
</ul>
</li>
<li>移动 IP 通信过程<ul>
<li>本地地址，转交地址，移动绑定 </li>
</ul>
</li>
</ol>
</li>
<li><p>网络层设备</p>
<ol>
<li>路由器的组成和功能<ul>
<li>任务是连接异构网络并完成路由转发</li>
<li>路由器隔离了广播域</li>
<li>结构：路由选择和分组转发；模型：路由器是网络层设备，实现下三层</li>
<li>存储转发设备<ul>
<li>网桥实现了物理层和数据链路层，那么网桥可以互联两个物理层和数据链路层不同的网络</li>
<li>但中继器是直通式设备，实现物理层后，却不能互联两个物理层不同的网段。</li>
</ul>
</li>
<li>路由选择处理机</li>
<li>分组转发：交换结构，一组输入端口，一组输出端口<ul>
<li>交换方法：存储器，总线，互联网络</li>
</ul>
</li>
</ul>
</li>
<li>路由表与路由转发<ul>
<li>路由表项：目的网络 IP 地址、子网掩码、下一跳 IP 地址、接口</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="五、传输层-1"><a href="#五、传输层-1" class="headerlink" title="五、传输层"></a>五、传输层</h2><p><img src="pat\cn0032.png" alt="image-20200509154102961"></p>
<h2 id="六、应用层-1"><a href="#六、应用层-1" class="headerlink" title="六、应用层"></a>六、应用层</h2><h1 id="Examination-Syllabus"><a href="#Examination-Syllabus" class="headerlink" title="Examination Syllabus"></a>Examination Syllabus</h1><ul>
<li><p>基础级</p>
<blockquote>
<blockquote>
<p>中文题目只涉及初级编程分5个段位</p>
</blockquote>
<p>青铜</p>
<blockquote>
<p>理解并掌握简单数据类型及表达式、程序的顺序执行结构和简单分支结构。具备使用一门编程语言进行简单的计算、基本的格式化输入输出以及解决简单分支问题的能力。</p>
</blockquote>
<p>白银</p>
<blockquote>
<p>在达到青铜段位要求的基础上，理解并掌握程序的循环结构。具备编程解决复杂嵌套分支和嵌套循环问题的能力。</p>
</blockquote>
<p>黄金</p>
<blockquote>
<p>在达到白银段位要求的基础上， 理解并掌握数组（包括高维数组和字符串）和结构体等概念，具备编程解决相关问题的能力。</p>
</blockquote>
<p>白金</p>
<blockquote>
<p>在达到黄金段位要求的基础上，理解并掌握函数和递归的概念，具备使用函数和递归解决较为复杂的综合性问题的能力，并掌握一定的调试技巧。</p>
</blockquote>
<p>钻石</p>
<blockquote>
<p>在达到白金段位要求的基础上，掌握简单排序、二分查找算法，具备解决较为复杂的综合性问题的能力，能够编写并调试代码量超过50行的程序。</p>
</blockquote>
</blockquote>
</li>
<li><p>乙级</p>
<blockquote>
<blockquote>
<p>中文题目只涉及基础编程最难到排序算法  </p>
</blockquote>
<p>考生应具备以下基本能力：   </p>
<pre><code>  1. 基本的C/C++的代码设计能力，以及相关开发环境的基本调试技巧；   
  2. 理解并掌握最基本的数据存储结构，即：数组、链表；   
  3. 理解并熟练编程实现与基本数据结构相关的基础算法，包括递归、排序、查找等；   
  4. 能够分析算法的时间复杂度、空间复杂度和算法稳定性；   
  5. 具备问题抽象和建模的初步能力，并能够用所学方法解决实际问题。     
</code></pre></blockquote>
</li>
<li><p>甲级</p>
<blockquote>
<blockquote>
<p>英文题目涉及基础数据结构</p>
</blockquote>
<p>在达到乙级要求的基础上，还要求：   </p>
<pre><code>  1. 具有充分的英文阅读理解能力；   
  2. 理解并掌握基础数据结构，包括：线性表、树、图；   
  3. 理解并熟练编程实现经典高级算法，包括哈希映射、并查集、最短路径、拓扑排序、关键路径、贪心、深度优先搜索、广度优先搜索、回溯剪枝等；   
  4. 具备较强的问题抽象和建模能力，能实现对复杂实际问题的模拟求解。   
</code></pre></blockquote>
</li>
</ul>
<ul>
<li>顶级<blockquote>
<blockquote>
<p>国际竞赛水平相当涉及高级数据结构与经典算法的应用</p>
</blockquote>
<p>在达到甲级要求的基础上，还要求：   </p>
<pre><code>  1. 对高级、复杂数据结构掌握其用法并能够熟练使用，如后缀数组、树状数组、线段树、Treap、静态KDTree等；   
  2. 能够利用经典算法思想解决较难的算法问题，如动态规划、计算几何、图论高级应用（包括最大流/最小割，强连通分支、最近公共祖先、最小生成树、欧拉序列）等，并灵活运用；   
  3. 能够解决复杂的模拟问题，编写并调试代码量较大的程序；   
  4. 具有缜密的科学思维，考虑问题周全，能够正确应对复杂问题的边界情况。   
</code></pre></blockquote>
</li>
</ul>
<p>PAT</p>
<ul>
<li><p><a href="https://m.baidu.com/ala/c/www.360doc.cn/mip/758686899.html" target="_blank" rel="noopener">PAT准备，希望甲级高分，该如何高效地准备？如何算是真正有效地刷题？</a></p>
</li>
<li><p>《算法导论》</p>
</li>
<li><p>学会C++</p>
</li>
<li><p>数据结构我大概学了这几块：</p>
<pre><code>线性结构：数组，栈，队列看一下就过了；链表自己实现了一遍；常见排序理解并会写。
树：二叉搜索树熟练（尤其是各种遍历）；AVL树和红黑树尽力理解了一下，我是真的记不住……
图：BFS, DFS, 最短路（dijkstra, spfa, floyd）。这里的题目最常见，要能写得很灵活。
其它：堆，背包问题（良心教程https://github.com/tianyicui/pack/blob/master/V2.pdf），贪心问题， KMP（还没遇到过题目）。
</code></pre></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://wenku.baidu.com/view/f3098732f342336c1eb91a37f111f18583d00c32.html" target="_blank" rel="noopener">大纲</a></li>
</ul>
